```mqh
// Settings.mqh
// این فایل به عنوان پنل کنترل مرکزی عمل می‌کند و تمام پارامترهای ورودی کاربر (inputs) و ثابت‌های سیستم را تعریف می‌کند.
// این تنظیمات اجازه می‌دهد تا کاربر سیستم را سفارشی‌سازی کند بدون نیاز به تغییر کد اصلی.
// تمام پارامترها با پیشوند Inp_ شروع می‌شوند تا به راحتی شناسایی شوند.
// این فایل برای بهینه‌سازی در متاتریدر ۵ طراحی شده و از enumها برای گزینه‌های انتخابی استفاده می‌کند تا خطای انسانی کاهش یابد.

// جلوگیری از تکرار تعریف هدر با استفاده از گارد پیش‌پردازنده برای جلوگیری از کامپایل چندباره
#ifndef SETTINGS_MQH
#define SETTINGS_MQH

// تعریف enum برای منطق خروج از معامله - این enum گزینه‌های خروج را محدود می‌کند تا کاربر گزینه اشتباه انتخاب نکند
enum ENUM_EXIT_LOGIC
{
   EXIT_DYNAMIC,    // خروج دینامیک: بر اساس اندیکاتورها مانند کیجون-سن (برای کنسی) یا خط میانی بولینگر (برای هاپلیت) - مناسب برای بازارهای پویا
   EXIT_RRR         // خروج ثابت: بر اساس نسبت ریسک به ریوارد (RRR) - مناسب برای استراتژی‌های ثابت و کنترل‌شده
};

// تعریف enum برای انواع سیگنال‌ها - SIGNAL_NONE نشان‌دهنده عدم سیگنال است تا در کد به راحتی چک شود
enum SIGNAL { SIGNAL_NONE, SIGNAL_LONG, SIGNAL_SHORT };

// پارامترهای ورودی کاربر - این بخش اجازه سفارشی‌سازی را می‌دهد
// سرمایه اولیه مجازی برای محاسبات
input double Inp_TotalInitialCapital = 10000.0; // سرمایه اولیه مجازی: برای محاسبات حجم لات و افت سرمایه استفاده می‌شود - این مقدار واقعی نیست، بلکه مبنای محاسباتی است

// وزن‌های تخصیص سرمایه به موتورها - مجموع باید ۱.۰ باشد، اما سیستم نرمال‌سازی دارد تا خطای انسانی را مدیریت کند
input double Inp_Kensei_Weight = 0.60; // وزن تخصیص سرمایه برای موتور کنسی (از ۰.۰ تا ۱.۰) - موتور تهاجمی برای روندها
input double Inp_Hoplite_Weight = 0.40; // وزن تخصیص سرمایه برای موتور هاپلیت (از ۰.۰ تا ۱.۰) - موتور دفاعی برای رنج‌ها

// مدیریت ریسک پورتفولیو
input double Inp_MaxPortfolioDrawdown = 0.09; // حداکثر درصد افت سرمایه پورتفولیو (مثلاً ۰.۰۹ = ۹٪) - اگر بیش از این شود، تمام پوزیشن‌ها بسته می‌شوند
input double Inp_Risk_Percent_Per_Trade=1;
// شناسایی معاملات
input ulong  Inp_BaseMagicNumber = 12345; // شماره جادویی پایه: برای شناسایی معاملات اکسپرت در متاتریدر استفاده می‌شود - باید منحصر به فرد باشد

// تنظیمات موتور کنسی (Kensei) - موتور روندگیر بر اساس ایچیموکو
input string Inp_Kensei_Symbols = "EURUSD,GBPUSD,XAUUSD"; // نمادهای معاملاتی کنسی: جدا شده با کاما - مثلاً EURUSD برای جفت ارز یورو دلار
input bool   Inp_Kensei_IsActive = true; // فعال کردن موتور کنسی: true برای فعال، false برای غیرفعال
input ENUM_TIMEFRAMES Inp_Kensei_Timeframe = PERIOD_H1; // تایم‌فریم کنسی: مثلاً PERIOD_H1 برای ساعتی
input int    Inp_Kensei_Tenkan = 9; // دوره تنکان-سن در ایچیموکو: میانگین کوتاه‌مدت
input int    Inp_Kensei_Kijun = 26; // دوره کیجون-سن در ایچیموکو: میانگین میان‌مدت، برای خروج دینامیک استفاده می‌شود
input int    Inp_Kensei_SenkouB = 52; // دوره سنکو اسپن بی در ایچیموکو: برای ابر کومو
input int    Inp_Kensei_ATR_Period = 14; // دوره ATR برای محاسبه حد ضرر کنسی
input double Inp_Kensei_ATR_Multiplier = 3.0; // ضریب ATR برای فاصله حد ضرر کنسی - مثلاً ۳ برابر ATR
input int    Inp_Kensei_Chikou_OpenSpace = 12; // دوره فضای باز چیکو اسپن: برای چک فضای باز گذشته - نکته: بلوپرینت ۱۲، اما ممکن است ۱۲۰ بهتر باشد، با بک‌تست چک کنید

// تنظیمات موتور هاپلیت (Hoplite) - موتور بازگشت به میانگین بر اساس بولینگر، RSI و ADX
input string Inp_Hoplite_Symbols = "EURUSD,GBPUSD,XAUUSD"; // نمادهای معاملاتی هاپلیت: جدا شده با کاما
input bool   Inp_Hoplite_IsActive = true; // فعال کردن موتور هاپلیت: true برای فعال
input ENUM_TIMEFRAMES Inp_Hoplite_Timeframe = PERIOD_H1; // تایم‌فریم هاپلیت
input int    Inp_Hoplite_BB_Period = 20; // دوره بولینگر بندز: برای محاسبه باندها
input double Inp_Hoplite_BB_Deviation = 2.5; // انحراف استاندارد بولینگر بندز: برای عرض باندها
input int    Inp_Hoplite_RSI_Period = 14; // دوره RSI: برای تشخیص بیش‌خرید/بیش‌فروش
input double Inp_Hoplite_RSI_Overbought = 75.0; // سطح بیش‌خرید RSI: بالای این مقدار فروش
input double Inp_Hoplite_RSI_Oversold = 25.0; // سطح بیش‌فروش RSI: پایین این مقدار خرید
input int    Inp_Hoplite_ADX_Period = 14; // دوره ADX: برای تشخیص روند
input double Inp_Hoplite_ADX_Threshold = 25.0; // آستانه ADX: بالای این مقدار بازار رونددار است و سیگنال نمی‌دهد
input double Inp_Hoplite_StopLoss_ATR_Multiplier = 2.0; // ضریب ATR برای حد ضرر هاپلیت

// منطق خروج عمومی
input ENUM_EXIT_LOGIC Inp_ExitLogic = EXIT_DYNAMIC; // نوع منطق خروج: دینامیک یا RRR
input double Inp_RiskRewardRatio = 3.0; // نسبت ریسک به ریوارد برای خروج RRR: مثلاً ۳ یعنی TP سه برابر SL

// نمایش و لاگینگ
input bool Inp_Show_Kensei_Indicators = false; // نمایش اندیکاتورهای کنسی روی چارت: برای دیباگینگ
input bool Inp_Show_Hoplite_Indicators = false; // نمایش اندیکاتورهای هاپلیت روی چارت
input bool Inp_Show_OnChart_Display = true; // نمایش پنل اطلاعات روی چارت: برای نظارت زنده
input bool Inp_EnableLogging = true; // فعال کردن سیستم لاگینگ: برای ثبت رویدادها در فایل

// ثابت‌های سیستم - این‌ها تغییر نمی‌کنند
const string COMMENT_PREFIX = "[ChimeraV2] "; // پیشوند کامنت معاملات: برای شناسایی در لیست معاملات متاتریدر

// پایان گارد پیش‌پردازنده
#endif



// Chimera_V2_EA.mq5
// این فایل اصلی اکسپرت است که تمام اجزا را هماهنگ می‌کند. این اکسپرت برای متاتریدر ۵ بهینه‌سازی شده و از تایمر برای چک دوره‌ای استفاده می‌کند.
// سیستم دو موتور دارد: کنسی (تهاجمی، روندگیر) و هاپلیت (دفاعی، بازگشت به میانگین).
// تمام عملیات با لاگینگ دقیق همراه است تا برای دیباگینگ و آموزش مناسب باشد.
// برای مقاومت در برابر خطای انسانی، وزن‌ها نرمال‌سازی می‌شوند.

// مشخصات کپی‌رایت و نسخه برای شناسایی در متاتریدر
#property copyright "Chimera V2.0" // کپی‌رایت اکسپرت
#property version   "2.00" // نسخه اکسپرت - برای پیگیری به‌روزرسانی‌ها
#property strict // حالت strict: برای کامپایل دقیق و جلوگیری از اشتباهات قدیمی MQL4

// اینکلود فایل‌های هدر لازم - هر فایل مسئولیت خاصی دارد
#include "Settings.mqh" // تنظیمات ورودی کاربر و ثابت‌ها
#include "Logging.mqh" // سیستم لاگینگ برای ثبت رویدادها
#include "MoneyManagement.mqh" // مدیریت پول، ریسک و باز کردن معاملات
#include "Engine_Kensei.mqh" // موتور کنسی برای سیگنال‌های روند
#include "Engine_Hoplite.mqh" // موتور هاپلیت برای سیگنال‌های رنج

// متغیرهای جهانی - این‌ها در سراسر اکسپرت قابل دسترسی هستند
// آرایه‌ها برای نمادها و زمان‌های آخرین بار - برای تشخیص بار جدید
string kensei_syms[]; // آرایه نمادهای موتور کنسی - از ورودی کاربر پر می‌شود
datetime last_kensei_times[]; // آرایه زمان آخرین بار برای هر نماد کنسی - برای جلوگیری از پردازش تکراری
string hoplite_syms[]; // آرایه نمادهای موتور هاپلیت
datetime last_hoplite_times[]; // آرایه زمان آخرین بار برای هر نماد هاپلیت
// هندل‌های اندیکاتورها - برای دسترسی سریع به داده‌های اندیکاتور
int g_kensei_ichi_handles[]; // هندل‌های ایچیموکو برای کنسی - یکی برای هر نماد
int g_kensei_atr_handles[]; // هندل‌های ATR برای کنسی
int g_hoplite_bb_handles[]; // هندل‌های بولینگر برای هاپلیت
int g_hoplite_rsi_handles[]; // هندل‌های RSI برای هاپلیت
int g_hoplite_adx_handles[]; // هندل‌های ADX برای هاپلیت
int g_hoplite_atr_handles[]; // هندل‌های ATR برای هاپلیت
// متغیرهای جهانی برای تنظیمات نرمال‌شده - برای مدیریت خطای انسانی در ورودی‌ها
double g_Kensei_Weight; // وزن نرمال‌شده کنسی
double g_Hoplite_Weight; // وزن نرمال‌شده هاپلیت
bool g_Kensei_IsActive; // وضعیت فعال کنسی - ممکن است در نرمال‌سازی تغییر کند
bool g_Hoplite_IsActive; // وضعیت فعال هاپلیت
double g_peak_equity = 0.0;
// تابع OnInit: راه‌اندازی اولیه اکسپرت - این تابع هنگام لود اکسپرت فراخوانی می‌شود
int OnInit()
{
   Log("شروع Chimera V2.0"); // لاگ شروع سیستم برای ثبت در فایل و ترمینال
   LogInit(); // راه‌اندازی سیستم لاگینگ - باز کردن فایل لاگ
   
   // تقسیم رشته نمادها به آرایه - برای پردازش چند نماد
   int kensei_count = StringSplit(Inp_Kensei_Symbols, ',', kensei_syms); // تقسیم نمادهای کنسی
   if (kensei_count <= 0) { LogError("خطا در تقسیم نمادهای کنسی: " + Inp_Kensei_Symbols); return INIT_FAILED; } // چک خطا و بازگشت شکست
   ArrayResize(last_kensei_times, kensei_count); // تنظیم اندازه آرایه زمان‌ها
   ArrayInitialize(last_kensei_times, 0); // مقداردهی اولیه به صفر (زمان نامعتبر)
   
   int hoplite_count = StringSplit(Inp_Hoplite_Symbols, ',', hoplite_syms); // تقسیم نمادهای هاپلیت
   if (hoplite_count <= 0) { LogError("خطا در تقسیم نمادهای هاپلیت: " + Inp_Hoplite_Symbols); return INIT_FAILED; } // چک خطا
   ArrayResize(last_hoplite_times, hoplite_count); // تنظیم اندازه
   ArrayInitialize(last_hoplite_times, 0); // مقداردهی اولیه
   
   // --- مقاوم‌سازی در برابر خطای انسانی: نرمال‌سازی وزن‌ها ---
   // این بخش وزن‌ها را چک و نرمال می‌کند تا مجموع همیشه ۱.۰ باشد
   g_Kensei_Weight = Inp_Kensei_Weight; // مقدار اولیه از ورودی
   g_Hoplite_Weight = Inp_Hoplite_Weight; // مقدار اولیه
   g_Kensei_IsActive = Inp_Kensei_IsActive; // وضعیت اولیه
   g_Hoplite_IsActive = Inp_Hoplite_IsActive; // وضعیت اولیه
   double total_weight = g_Kensei_Weight + g_Hoplite_Weight; // محاسبه مجموع
   if (total_weight <= 0) // اگر مجموع نامعتبر (صفر یا منفی)
   {
      LogError("مجموع وزن‌های تخصیص یافته صفر یا منفی است. موتورها غیرفعال می‌شوند."); // لاگ خطا
      g_Kensei_IsActive = false; // غیرفعال کردن موتورها
      g_Hoplite_IsActive = false; // غیرفعال کردن
   }
   else if (total_weight != 1.0) // اگر مجموع دقیقاً ۱.۰ نیست (برای جلوگیری از ریسک بیش از حد)
   {
      Log("هشدار: مجموع وزن‌ها (" + DoubleToString(total_weight, 2) + ") برابر با ۱.۰ نیست. نرمال‌سازی انجام می‌شود."); // لاگ هشدار
      // نرمال‌سازی: تقسیم هر وزن بر مجموع برای حفظ نسبت
      g_Kensei_Weight = g_Kensei_Weight / total_weight; // وزن جدید کنسی
      g_Hoplite_Weight = g_Hoplite_Weight / total_weight; // وزن جدید هاپلیت
      Log("وزن جدید کنسی: " + DoubleToString(g_Kensei_Weight, 2) + ", وزن جدید هاپلیت: " + DoubleToString(g_Hoplite_Weight, 2)); // لاگ وزن‌های جدید
   }
   // --- پایان نرمال‌سازی وزن‌ها ---
   
   // ایجاد هندل‌های اندیکاتور برای کنسی
   ArrayResize(g_kensei_ichi_handles, kensei_count); // تنظیم اندازه آرایه هندل‌ها
   ArrayResize(g_kensei_atr_handles, kensei_count); // تنظیم اندازه
   for (int i = 0; i < kensei_count; i++) // حلقه برای هر نماد
   {
      g_kensei_ichi_handles[i] = iIchimoku(kensei_syms[i], Inp_Kensei_Timeframe, Inp_Kensei_Tenkan, Inp_Kensei_Kijun, Inp_Kensei_SenkouB); // ایجاد هندل ایچیموکو
      g_kensei_atr_handles[i] = iATR(kensei_syms[i], Inp_Kensei_Timeframe, Inp_Kensei_ATR_Period); // ایجاد هندل ATR
      if (g_kensei_ichi_handles[i] == INVALID_HANDLE || g_kensei_atr_handles[i] == INVALID_HANDLE) // چک هندل نامعتبر
      {
         LogError("خطا در ایجاد هندل کنسی برای نماد: " + kensei_syms[i]); // لاگ خطا
         return INIT_FAILED; // بازگشت با شکست ابتدایی
      }
   }
   
   // ایجاد هندل‌های اندیکاتور برای هاپلیت
   ArrayResize(g_hoplite_bb_handles, hoplite_count); // تنظیم اندازه
   ArrayResize(g_hoplite_rsi_handles, hoplite_count); // تنظیم اندازه
   ArrayResize(g_hoplite_adx_handles, hoplite_count); // تنظیم اندازه
   ArrayResize(g_hoplite_atr_handles, hoplite_count); // تنظیم اندازه
   for (int i = 0; i < hoplite_count; i++) // حلقه برای هر نماد
   {
      g_hoplite_bb_handles[i] = iBands(hoplite_syms[i], Inp_Hoplite_Timeframe, Inp_Hoplite_BB_Period, 0, Inp_Hoplite_BB_Deviation, PRICE_CLOSE); // ایجاد هندل بولینگر
      g_hoplite_rsi_handles[i] = iRSI(hoplite_syms[i], Inp_Hoplite_Timeframe, Inp_Hoplite_RSI_Period, PRICE_CLOSE); // ایجاد هندل RSI
      g_hoplite_adx_handles[i] = iADX(hoplite_syms[i], Inp_Hoplite_Timeframe, Inp_Hoplite_ADX_Period); // ایجاد هندل ADX
      g_hoplite_atr_handles[i] = iATR(hoplite_syms[i], Inp_Hoplite_Timeframe, 14); // ایجاد هندل ATR (دوره ثابت ۱۴)
      if (g_hoplite_bb_handles[i] == INVALID_HANDLE || g_hoplite_rsi_handles[i] == INVALID_HANDLE || 
          g_hoplite_adx_handles[i] == INVALID_HANDLE || g_hoplite_atr_handles[i] == INVALID_HANDLE) // چک هندل نامعتبر
      {
         LogError("خطا در ایجاد هندل هاپلیت برای نماد: " + hoplite_syms[i]); // لاگ خطا
         return INIT_FAILED; // بازگشت شکست
      }
   }
   
   // نمایش اندیکاتورها روی چارت اگر فعال باشد - فقط برای نماد فعلی چارت
   if (Inp_Show_Kensei_Indicators) // چک گزینه نمایش کنسی
   {
      iIchimoku(_Symbol, Inp_Kensei_Timeframe, Inp_Kensei_Tenkan, Inp_Kensei_Kijun, Inp_Kensei_SenkouB); // نمایش ایچیموکو
      Log("اندیکاتورهای کنسی نمایش داده شد"); // لاگ نمایش
   }
   if (Inp_Show_Hoplite_Indicators) // چک گزینه نمایش هاپلیت
   {
      iBands(_Symbol, Inp_Hoplite_Timeframe, Inp_Hoplite_BB_Period, 0, Inp_Hoplite_BB_Deviation, PRICE_CLOSE); // نمایش بولینگر
      iRSI(_Symbol, Inp_Hoplite_Timeframe, Inp_Hoplite_RSI_Period, PRICE_CLOSE); // نمایش RSI
      iADX(_Symbol, Inp_Hoplite_Timeframe, Inp_Hoplite_ADX_Period); // نمایش ADX
      Log("اندیکاتورهای هاپلیت نمایش داده شد"); // لاگ نمایش
   }
   if (Inp_Show_OnChart_Display) // چک نمایش پنل
   {
      Log("پنل اطلاعات روی چارت نمایش داده شد"); // لاگ نمایش (پنل واقعی باید پیاده شود اگر لازم)
   }
   g_peak_equity = AccountInfoDouble(ACCOUNT_EQUITY); // تنظیم اوج اکویتی اولیه برای محاسبه افت
   Log("اوج اکویتی اولیه تنظیم شد: " + DoubleToString(g_peak_equity, 2)); // لاگ مقدار
   EventSetTimer(1); // تنظیم تایمر هر ۱ ثانیه برای چک دوره‌ای - بهینه برای متاتریدر
   return(INIT_SUCCEEDED); // بازگشت موفق ابتدایی
}

// تابع OnDeinit: خاموش کردن اکسپرت - هنگام unload فراخوانی می‌شود
void OnDeinit(const int reason)
{
   Log("توقف Chimera V2.0 با دلیل: " + IntegerToString(reason)); // لاگ دلیل توقف (reason کد متاتریدر است)
   EventKillTimer(); // خاموش کردن تایمر برای جلوگیری از فراخوانی OnTimer
   // آزاد کردن هندل‌های اندیکاتور برای مدیریت حافظه
   for (int i = 0; i < ArraySize(g_kensei_ichi_handles); i++) // حلقه برای کنسی
   {
      if (g_kensei_ichi_handles[i] != INVALID_HANDLE) IndicatorRelease(g_kensei_ichi_handles[i]); // آزاد کردن ایچیموکو
      if (g_kensei_atr_handles[i] != INVALID_HANDLE) IndicatorRelease(g_kensei_atr_handles[i]); // آزاد کردن ATR
   }
   for (int i = 0; i < ArraySize(g_hoplite_bb_handles); i++) // حلقه برای هاپلیت
   {
      if (g_hoplite_bb_handles[i] != INVALID_HANDLE) IndicatorRelease(g_hoplite_bb_handles[i]); // آزاد کردن بولینگر
      if (g_hoplite_rsi_handles[i] != INVALID_HANDLE) IndicatorRelease(g_hoplite_rsi_handles[i]); // آزاد کردن RSI
      if (g_hoplite_adx_handles[i] != INVALID_HANDLE) IndicatorRelease(g_hoplite_adx_handles[i]); // آزاد کردن ADX
      if (g_hoplite_atr_handles[i] != INVALID_HANDLE) IndicatorRelease(g_hoplite_atr_handles[i]); // آزاد کردن ATR
   }
   LogDeinit(); // خاموش کردن لاگینگ - بستن فایل
}

// تابع OnTimer: چک دوره‌ای هر ۱ ثانیه - برای تشخیص بار جدید و مدیریت
void OnTimer()
{
  // Log("چک تایمر - ارزیابی پورتفولیو و سیگنال‌ها"); // لاگ هر چک برای پیگیری عملکرد
   if (IsPortfolioDrawdownExceeded()) // چک افت سرمایه بیش از حد
   {
      Log("افت سرمایه بیش از حد تشخیص داده شد - بستن تمام پوزیشن‌ها"); // لاگ اقدام اضطراری
      CloseAllPositions(); // بستن تمام پوزیشن‌ها برای حفاظت سرمایه
      return; // بازگشت زود برای جلوگیری از باز کردن معاملات جدید
   }
   if (g_Kensei_IsActive) // چک فعال بودن کنسی (پس از نرمال‌سازی)
   {
      for (int i = 0; i < ArraySize(kensei_syms); i++) // حلقه برای هر نماد کنسی
      {
         datetime current_time = iTime(kensei_syms[i], Inp_Kensei_Timeframe, 0); // زمان بار فعلی
         if (current_time > last_kensei_times[i]) // اگر بار جدید (برای جلوگیری از پردازش تکراری)
         {
            Log("بار جدید در تایم‌فریم کنسی برای نماد " + kensei_syms[i]); // لاگ بار جدید
            last_kensei_times[i] = current_time; // به‌روزرسانی زمان
            SIGNAL sig = GetKenseiSignal(kensei_syms[i], g_kensei_ichi_handles[i], g_kensei_atr_handles[i]); // گرفتن سیگنال
            OpenTrade(kensei_syms[i], sig, 1, g_kensei_atr_handles[i]); // باز کردن معامله اگر سیگنال باشد
         }
      }
   }
   if (g_Hoplite_IsActive) // چک فعال بودن هاپلیت
   {
      for (int i = 0; i < ArraySize(hoplite_syms); i++) // حلقه برای هر نماد
      {
         datetime current_time = iTime(hoplite_syms[i], Inp_Hoplite_Timeframe, 0); // زمان بار فعلی
         if (current_time > last_hoplite_times[i]) // بار جدید
         {
            Log("بار جدید در تایم‌فریم هاپلیت برای نماد " + hoplite_syms[i]); // لاگ
            last_hoplite_times[i] = current_time; // به‌روزرسانی
            SIGNAL sig = GetHopliteSignal(hoplite_syms[i], g_hoplite_bb_handles[i], g_hoplite_rsi_handles[i], g_hoplite_adx_handles[i]); // سیگنال
            OpenTrade(hoplite_syms[i], sig, 2, g_hoplite_atr_handles[i]); // باز کردن
         }
      }
   }
 
ManageTrades(); // مدیریت پوزیشن‌های باز - چک خروج

// --- ذخیره دوره‌ای بافر لاگ ---
// هر 30 ثانیه یک‌بار، لاگ‌های جمع‌شده در بافر را روی فایل ذخیره می‌کنیم
if(TimeCurrent() - g_last_flush_time >= 30)
{
   FlushLogBuffer();
}

}

// تابع ManageTrades: مدیریت پوزیشن‌های باز - چک شرایط خروج برای هر موتور
void ManageTrades()
{
   Log("شروع مدیریت معاملات باز"); // لاگ شروع
   for (int i = PositionsTotal() - 1; i >= 0; i--) // حلقه از آخرین پوزیشن (برای جلوگیری از مشکلات ایندکس)
   {
      ulong ticket = PositionGetTicket(i); // گرفتن تیکت
      if (ticket == 0) continue; // اگر نامعتبر، رد شود
      ulong magic = PositionGetInteger(POSITION_MAGIC); // شماره جادویی برای شناسایی موتور
      string symbol = PositionGetString(POSITION_SYMBOL); // نماد پوزیشن
      if (magic == Inp_BaseMagicNumber + 1) // اگر کنسی
      {
         int sym_index = -1; // جستجو برای ایندکس نماد
         for (int j = 0; j < ArraySize(kensei_syms); j++)
         {
            if (kensei_syms[j] == symbol) { sym_index = j; break; } // پیدا کردن ایندکس
         }
         if (sym_index != -1) // اگر پیدا شد
         {
            ManageKenseiExit(ticket, g_kensei_ichi_handles[sym_index]); // مدیریت خروج کنسی
         }
         else // اگر نه
         {
            LogError("نماد " + symbol + " در لیست کنسی برای تیکت " + IntegerToString(ticket) + " پیدا نشد"); // لاگ خطا
         }
      }
      else if (magic == Inp_BaseMagicNumber + 2) // اگر هاپلیت
      {
         int sym_index = -1;
         for (int j = 0; j < ArraySize(hoplite_syms); j++)
         {
            if (hoplite_syms[j] == symbol) { sym_index = j; break; }
         }
         if (sym_index != -1)
         {
            ManageHopliteExit(ticket, g_hoplite_bb_handles[sym_index]); // مدیریت خروج هاپلیت
         }
         else
         {
            LogError("نماد " + symbol + " در لیست هاپلیت برای تیکت " + IntegerToString(ticket) + " پیدا نشد"); // لاگ خطا
         }
      }
   }
   Log("پایان مدیریت معاملات"); // لاگ پایان
}

// تابع CloseAllPositions: بستن تمام پوزیشن‌ها در شرایط اضطراری مانند افت بیش از حد
void CloseAllPositions()
{
   Log("شروع بستن تمام پوزیشن‌ها"); // لاگ شروع
   CTrade trade; // شیء تجارت برای عملیات بستن
   for (int i = PositionsTotal() - 1; i >= 0; i--) // حلقه از آخرین
   {
      ulong ticket = PositionGetTicket(i); // تیکت
      if (ticket == 0) continue; // رد نامعتبر
      string symbol = PositionGetString(POSITION_SYMBOL); // نماد
      long type = PositionGetInteger(POSITION_TYPE); // نوع (خرید/فروش)
      double close_price = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(symbol, SYMBOL_BID) : SymbolInfoDouble(symbol, SYMBOL_ASK); // قیمت بسته شدن
      if (trade.PositionClose(ticket, 3)) // سعی در بستن با slippage 3
         LogCloseTrade(ticket, "افت سرمایه بیش از حد"); // لاگ موفق
      else
         LogError("خطا در بستن پوزیشن تیکت " + IntegerToString(ticket) + ": " + IntegerToString(trade.ResultRetcode())); // لاگ خطا
   }
   Log("پایان بستن پوزیشن‌ها"); // لاگ پایان
}



// Engine_Hoplite.mqh
// این فایل موتور دفاعی هاپلیت را پیاده‌سازی می‌کند که از استراتژی بازگشت به میانگین (mean-reversion) استفاده می‌کند.
// بر اساس بولینگر بندز، RSI و ADX برای تشخیص رنج و بیش‌خرید/بیش‌فروش.
// برای متاتریدر ۵ بهینه‌سازی شده با چک‌های دقیق برای هندل‌ها و داده‌ها.
// تمام عملیات با لاگینگ برای آموزش و دیباگ.

// جلوگیری از تکرار تعریف هدر
#ifndef ENGINE_HOPLITE_MQH
#define ENGINE_HOPLITE_MQH

// اینکلود فایل‌های لازم - وابستگی‌ها حداقل نگه داشته شده
#include "Settings.mqh" // تنظیمات و enumها
#include "Logging.mqh" // لاگینگ
#include "MoneyManagement.mqh" // مدیریت معامله (برای SIGNAL)

// تابع GetHopliteSignal: تولید سیگنال برای هاپلیت - فقط در بازار رنج
SIGNAL GetHopliteSignal(string symbol, int bb_handle, int rsi_handle, int adx_handle)
{
   Log("شروع چک سیگنال هاپلیت برای نماد: " + symbol); // لاگ شروع برای پیگیری گام‌به‌گام
   // چک هندل‌های اندیکاتور - برای جلوگیری از crash
   if (bb_handle == INVALID_HANDLE) { LogError("هندل BB نامعتبر برای " + symbol); return SIGNAL_NONE; }
   if (rsi_handle == INVALID_HANDLE) { LogError("هندل RSI نامعتبر برای " + symbol); return SIGNAL_NONE; }
   if (adx_handle == INVALID_HANDLE) { LogError("هندل ADX نامعتبر برای " + symbol); return SIGNAL_NONE; }

   // آرایه‌های داده - اندازه ۱ برای کندل قبلی
   double bb_upper[1], bb_lower[1]; // باندها
   double rsi[1], adx[1]; // RSI و ADX
   double close[1]; // قیمت بسته شدن قبلی

   // کپی داده‌ها از بافر - ایندکس ۱ برای کندل قبلی (کامل‌شده)
   if(CopyBuffer(bb_handle, 1, 1, 1, bb_upper) <= 0) { LogError("هاپلیت: خطا در کپی باند بالا BB برای " + symbol); return SIGNAL_NONE; }
   if(CopyBuffer(bb_handle, 2, 1, 1, bb_lower) <= 0) { LogError("هاپلیت: خطا در کپی باند پایین BB برای " + symbol); return SIGNAL_NONE; }
   if(CopyBuffer(rsi_handle, 0, 1, 1, rsi) <= 0) { LogError("هاپلیت: خطا در کپی RSI برای " + symbol); return SIGNAL_NONE; }
   if(CopyBuffer(adx_handle, 0, 1, 1, adx) <= 0) { LogError("هاپلیت: خطا در کپی ADX برای " + symbol); return SIGNAL_NONE; }
   if(CopyClose(symbol, Inp_Hoplite_Timeframe, 1, 1, close) < 1) { LogError("هاپلیت: خطا در کپی بسته شدن قبلی برای " + symbol); return SIGNAL_NONE; }

   // چک بازار رونددار با ADX - اگر رونددار، سیگنال نده (هاپلیت برای رنج است)
   if(adx[0] >= Inp_Hoplite_ADX_Threshold)
   {
      Log("بازار رونددار تشخیص داده شد (ADX=" + DoubleToString(adx[0], 2) + ") - بدون سیگنال برای " + symbol); // لاگ دلیل
      return SIGNAL_NONE; // بازگشت بدون سیگنال
   }

   // شرط سیگنال خرید: قیمت زیر باند پایین و RSI بیش‌فروش
   if(close[0] < bb_lower[0] && rsi[0] < Inp_Hoplite_RSI_Oversold)
   {
      LogSignal(symbol, "هاپلیت", "خرید"); // لاگ سیگنال
      return SIGNAL_LONG; // سیگنال خرید
   }

   // شرط سیگنال فروش: قیمت بالای باند بالا و RSI بیش‌خرید
   if(close[0] > bb_upper[0] && rsi[0] > Inp_Hoplite_RSI_Overbought)
   {
      LogSignal(symbol, "هاپلیت", "فروش"); // لاگ سیگنال
      return SIGNAL_SHORT; // سیگنال فروش
   }
   Log("بدون سیگنال در هاپلیت برای " + symbol); // لاگ عدم سیگنال
   return SIGNAL_NONE; // بازگشت پیش‌فرض
}

// تابع ManageHopliteExit: مدیریت خروج برای پوزیشن‌های هاپلیت
void ManageHopliteExit(ulong ticket, int bb_handle)
{
   Log("شروع مدیریت خروج هاپلیت برای تیکت: " + IntegerToString(ticket)); // لاگ شروع
   if (!PositionSelectByTicket(ticket)) { LogError("خطا در انتخاب پوزیشن برای خروج هاپلیت"); return; } // انتخاب پوزیشن
   string symbol = PositionGetString(POSITION_SYMBOL); // نماد
   long type = PositionGetInteger(POSITION_TYPE); // نوع (خرید/فروش)
   if (Inp_ExitLogic == EXIT_DYNAMIC) // اگر خروج دینامیک
   {
      if (bb_handle == INVALID_HANDLE) { LogError("هندل BB نامعتبر برای خروج در " + symbol); return; } // چک هندل
      double bb_mid[1]; // خط میانی بولینگر
      if (CopyBuffer(bb_handle, 0, 0, 1, bb_mid) <= 0) { LogError("خطا در کپی BB برای خروج در " + symbol); return; } // کپی داده (ایندکس ۰ برای کندل فعلی)
      double current_price = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(symbol, SYMBOL_BID) : SymbolInfoDouble(symbol, SYMBOL_ASK); // قیمت فعلی
      // شرط بسته شدن: برای خرید، قیمت به خط میانی برسد یا بالاتر؛ برای فروش، پایین‌تر
      bool close_cond = (type == POSITION_TYPE_BUY && current_price >= bb_mid[0]) || (type == POSITION_TYPE_SELL && current_price <= bb_mid[0]);
      if (close_cond) // اگر شرط برقرار
      {
         CTrade trade; // شیء تجارت
         if (trade.PositionClose(ticket, 3)) // بستن با slippage 3
            LogCloseTrade(ticket, "رسیدن به خط میانی BB"); // لاگ موفق
         else
            LogError("خطا در بستن پوزیشن دینامیک برای تیکت " + IntegerToString(ticket) + ": " + IntegerToString(trade.ResultRetcode())); // لاگ خطا
      }
      else
      {
         Log("شرط بسته شدن دینامیک برقرار نیست برای تیکت " + IntegerToString(ticket)); // لاگ عدم شرط
      }
   }
   else if (Inp_ExitLogic == EXIT_RRR) // اگر خروج RRR (TP ثابت چک می‌شود توسط متاتریدر)
   {
      Log("خروج RRR برای هاپلیت - چک TP برای تیکت " + IntegerToString(ticket)); // لاگ (در عمل TP در باز کردن تنظیم شده)
   }
   Log("پایان مدیریت خروج هاپلیت برای تیکت: " + IntegerToString(ticket)); // لاگ پایان
}

// پایان گارد
#endif

// Engine_Kensei.mqh
// نسخه بازنویسی شده توسط سقراط (Socrates) طبق بلوپرینت Chimera V2.0
// این فایل به طور کامل بازنویسی شده تا خطای حیاتی در محاسبه "ابر آینده" را برطرف کرده و منطق را شفاف‌سازی کند.
// تمام توضیحات لازم برای درک فلسفه پشت هر بخش از کد، در کامنت‌ها گنجانده شده است.

// جلوگیری از تکرار تعریف هدر
#ifndef ENGINE_KENSEI_MQH
#define ENGINE_KENSEI_MQH

// اینکلود فایل‌های لازم
#include "Settings.mqh" // تنظیمات ورودی کاربر و ثابت‌های سیستم
#include "Logging.mqh"   // سیستم پیشرفته لاگینگ برای ثبت وقایع
#include "MoneyManagement.mqh" // برای دسترسی به enum سیگنال

//==================================================================================================
// تابع اصلی تولید سیگنال برای موتور کنسی (Kensei)
// این تابع بر اساس ۴ شرط طلایی ایچیموکو که در بلوپرینت مشخص شده، عمل می‌کند.
//==================================================================================================
SIGNAL GetKenseiSignal(string symbol, int ichi_handle, int atr_handle)
{
   // لاگ شروع عملیات برای پیگیری و دیباگینگ
   Log("شروع چک سیگنال کنسی برای نماد: " + symbol);

   // --- بخش ۱: اعتبارسنجی ورودی‌ها ---
   // قبل از هر کاری، مطمئن می‌شویم که ابزارهای لازم (هندل‌های اندیکاتور) معتبر هستند.
   if(ichi_handle == INVALID_HANDLE)
   {
      LogError("هندل ایچیموکو برای کنسی در نماد " + symbol + " نامعتبر است. سیگنال‌گیری متوقف شد.");
      return SIGNAL_NONE;
   }
   if(atr_handle == INVALID_HANDLE)
   {
      LogError("هندل ATR برای کنسی در نماد " + symbol + " نامعتبر است. سیگنال‌گیری متوقف شد.");
      return SIGNAL_NONE;
   }

   // --- بخش ۲: آماده‌سازی متغیرها و دریافت داده‌های کندل تثبیت‌شده (کندل ۱) ---
   // فلسفه اصلی: برای صدور سیگنال، ما همیشه از کندل "تثبیت‌شده" یا "بسته شده" قبلی (ایندکس ۱) استفاده می‌کنیم.
   // چون کندل فعلی (ایندکس ۰) هنوز در حال حرکت است و می‌تواند سیگنال کاذب تولید کند.
   // بنابراین، تمام داده‌های مربوط به شرایط سیگنال (شکست ابر، وضعیت چیکو) از کندل ۱ خوانده می‌شوند.

   // آرایه‌ها برای ذخیره داده‌های ایچیموکو از کندل ۱ و ۲ (برای تشخیص کراس)
   double tenkan[1], kijun[1], ssa[2], ssb[2];
   double close[2];
   double chikou_compare_price[1];
   double past_highs[];
   double past_lows[];

   // کپی داده‌های ایچیموکو برای کندل ۱ (و ۲ برای ابر)
   if(CopyBuffer(ichi_handle, 0, 1, 1, tenkan) <= 0) { LogError("کنسی: خطا در کپی تنکان برای " + symbol); return SIGNAL_NONE; }
   if(CopyBuffer(ichi_handle, 1, 1, 1, kijun) <= 0) { LogError("کنسی: خطا در کپی کیجون برای " + symbol); return SIGNAL_NONE; }
   if(CopyBuffer(ichi_handle, 2, 1, 2, ssa) <= 0) { LogError("کنسی: خطا در کپی SSA برای " + symbol); return SIGNAL_NONE; }
   if(CopyBuffer(ichi_handle, 3, 1, 2, ssb) <= 0) { LogError("کنسی: خطا در کپی SSB برای " + symbol); return SIGNAL_NONE; }

   // کپی قیمت بسته شدن برای کندل ۱ و ۲
   if(CopyClose(symbol, Inp_Kensei_Timeframe, 1, 2, close) < 2) { LogError("کنسی: خطا در کپی قیمت‌های بسته شدن برای " + symbol); return SIGNAL_NONE; }

   // --- بخش ۳: محاسبه صحیح "ابر آینده" (Future Kumo) ---
   // نکته حیاتی و دلیل اصلی بازنویسی: "ابر آینده" یک پیش‌بینی است که باید بر اساس جدیدترین اطلاعات موجود انجام شود.
   // جدیدترین اطلاعات همیشه در کندل ۰ (کندل فعلی که در حال تشکیل است) قرار دارد.
   // بنابراین، برخلاف سایر محاسبات، برای این یک شرط خاص، ما از دیتای کندل ۰ استفاده می‌کنیم.
   double future_ssa[1], future_ssb[1];
   double current_tenkan[1], current_kijun[1];

   // دریافت تنکان و کیجون از کندل فعلی (ایندکس ۰)
   if(CopyBuffer(ichi_handle, 0, 0, 1, current_tenkan) <= 0) { LogError("کنسی: خطا در کپی تنکان فعلی برای محاسبه ابر آینده در " + symbol); return SIGNAL_NONE; }
   if(CopyBuffer(ichi_handle, 1, 0, 1, current_kijun) <= 0) { LogError("کنسی: خطا در کپی کیجون فعلی برای محاسبه ابر آینده در " + symbol); return SIGNAL_NONE; }

   // محاسبه Senkou Span A آینده بر اساس تنکان و کیجون فعلی
   future_ssa[0] = (current_tenkan[0] + current_kijun[0]) / 2.0;

   // محاسبه Senkou Span B آینده بر اساس بالاترین سقف و پایین‌ترین کف در ۵۲ کندل اخیر (شامل کندل فعلی)
   double high52[52], low52[52];
   if(CopyHigh(symbol, Inp_Kensei_Timeframe, 0, 52, high52) != 52 || CopyLow(symbol, Inp_Kensei_Timeframe, 0, 52, low52) != 52)
   {
      LogError("کنسی: خطا در کپی High/Low برای محاسبه SSB آینده در " + symbol);
      return SIGNAL_NONE;
   }
   future_ssb[0] = (ArrayMaximum(high52, 0, WHOLE_ARRAY) + ArrayMinimum(low52, 0, WHOLE_ARRAY)) / 2.0;


   // --- بخش ۴: بررسی شرایط چهارگانه سیگنال ---
   // حالا که تمام داده‌های لازم (هم از کندل ۱ و هم محاسبه آینده از کندل ۰) را داریم، شروط را بررسی می‌کنیم.

   // **شرط اول: شکست ابر کومو (Kumo Breakout)**
   // قیمت در کندل ۱ باید بالای/پایین ابر باشد، در حالی که در کندل ۲ اینطور نبوده است. این یعنی "کراس".
   bool is_kumo_breakout_long = close[0] > MathMax(ssa[0], ssb[0]) && close[1] <= MathMax(ssa[1], ssb[1]);
   bool is_kumo_breakout_short = close[0] < MathMin(ssa[0], ssb[0]) && close[1] >= MathMin(ssa[1], ssb[1]);

   // **شرط دوم: تایید ابر آینده (Future Kumo Confirmation)**
   // ابر آینده که بر اساس دیتای کندل ۰ محاسبه شده، باید هم‌جهت با شکست باشد.
   bool is_future_kumo_bullish = future_ssa[0] > future_ssb[0];
   bool is_future_kumo_bearish = future_ssa[0] < future_ssb[0];

   // **شرط سوم: تایید چیکو اسپن (Chikou Span Confirmation)**
   // مقدار چیکو (که قیمت بسته شدن کندل ۱ است) باید بالاتر/پایین‌تر از قیمت ۲۶ کندل قبل از خودش باشد.
   double chikou_value = close[0];
   if(CopyClose(symbol, Inp_Kensei_Timeframe, 1 + Inp_Kensei_Kijun, 1, chikou_compare_price) < 1) { LogError("کنسی: خطا در کپی قیمت گذشته برای مقایسه چیکو در " + symbol); return SIGNAL_NONE; }
   bool is_chikou_confirm_long = chikou_value > chikou_compare_price[0];
   bool is_chikou_confirm_short = chikou_value < chikou_compare_price[0];

   // **شرط چهارم: فیلتر فضای باز چیکو (Chikou Open Space Filter)**
   // مسیر حرکت چیکو نباید با قیمت‌های اخیر مسدود شده باشد.
   if(CopyHigh(symbol, Inp_Kensei_Timeframe, 1 + Inp_Kensei_Kijun, Inp_Kensei_Chikou_OpenSpace, past_highs) != Inp_Kensei_Chikou_OpenSpace) { LogError("خطا در کپی High برای فضای باز چیکو در " + symbol); return SIGNAL_NONE; }
   if(CopyLow(symbol, Inp_Kensei_Timeframe, 1 + Inp_Kensei_Kijun, Inp_Kensei_Chikou_OpenSpace, past_lows) != Inp_Kensei_Chikou_OpenSpace) { LogError("خطا در کپی Low برای فضای باز چیکو در " + symbol); return SIGNAL_NONE; }
   bool is_chikou_open_space_long = chikou_value > ArrayMaximum(past_highs, 0, WHOLE_ARRAY);
   bool is_chikou_open_space_short = chikou_value < ArrayMinimum(past_lows, 0, WHOLE_ARRAY);

   // --- بخش ۵: تصمیم‌گیری نهایی ---
   // اگر تمام ۴ شرط برای خرید برقرار باشند، سیگنال خرید صادر می‌شود.
   if(is_kumo_breakout_long && is_future_kumo_bullish && is_chikou_confirm_long && is_chikou_open_space_long)
   {
      LogSignal(symbol, "کنسی", "خرید");
      return SIGNAL_LONG;
   }

   // اگر تمام ۴ شرط برای فروش برقرار باشند، سیگنال فروش صادر می‌شود.
   if(is_kumo_breakout_short && is_future_kumo_bearish && is_chikou_confirm_short && is_chikou_open_space_short)
   {
      LogSignal(symbol, "کنسی", "فروش");
      return SIGNAL_SHORT;
   }

   // اگر هیچ‌کدام از شرایط بالا برقرار نبود، هیچ سیگنالی وجود ندارد.
   Log("بدون سیگنال در کنسی برای " + symbol);
   return SIGNAL_NONE;
}


//==================================================================================================
// تابع مدیریت خروج برای معاملات باز موتور کنسی
// این تابع مسئولیت حد ضرر متحرک (Trailing Stop) را بر عهده دارد.
//==================================================================================================
void ManageKenseiExit(ulong ticket, int ichi_handle)
{
   // لاگ شروع عملیات برای پیگیری
   Log("شروع مدیریت خروج کنسی برای تیکت: " + IntegerToString(ticket));

   // انتخاب پوزیشن با تیکت داده شده برای دسترسی به اطلاعات آن
   if(!PositionSelectByTicket(ticket))
   {
      LogError("خطا در انتخاب پوزیشن برای خروج کنسی با تیکت: " + (string)ticket);
      return;
   }

   // این منطق فقط زمانی اجرا می‌شود که کاربر در تنظیمات، خروج "دینامیک" را انتخاب کرده باشد.
   if(Inp_ExitLogic == EXIT_DYNAMIC)
   {
      // دریافت اطلاعات لازم از پوزیشن باز
      string symbol = PositionGetString(POSITION_SYMBOL);
      long type = PositionGetInteger(POSITION_TYPE);

      // اعتبارسنجی هندل ایچیموکو
      if(ichi_handle == INVALID_HANDLE) { LogError("هندل ایچیموکو برای خروج دینامیک در " + symbol + " نامعتبر است."); return; }

      // دریافت مقدار کیجون-سن از کندل تثبیت‌شده قبلی (ایندکس ۱)
      double kijun[1];
      if(CopyBuffer(ichi_handle, 1, 1, 1, kijun) <= 0) { LogError("خطا در کپی کیجون برای خروج در " + symbol); return; }

      // دریافت حد ضرر فعلی پوزیشن
      double current_sl = PositionGetDouble(POSITION_SL);
      // حد ضرر جدید پیشنهادی بر اساس کیجون-سن
      double new_sl = kijun[0];

      bool modify_position = false; // یک پرچم برای اینکه آیا نیاز به تغییر پوزیشن هست یا نه

      // منطق حد ضرر متحرک:
      // برای یک معامله خرید (Long)، حد ضرر فقط باید به سمت بالا حرکت کند و هرگز پایین نمی‌آید.
      if(type == POSITION_TYPE_BUY && new_sl > current_sl)
      {
         modify_position = true;
      }
      // برای یک معامله فروش (Short)، حد ضرر فقط باید به سمت پایین حرکت کند.
      else if(type == POSITION_TYPE_SELL && new_sl < current_sl && new_sl > 0)
      {
         modify_position = true;
      }

      // اگر نیاز به تغییر حد ضرر بود
      if(modify_position)
      {
         Log("تلاش برای به‌روزرسانی SL دینامیک برای تیکت " + (string)ticket + " از " + DoubleToString(current_sl, _Digits) + " به " + DoubleToString(new_sl, _Digits));
         CTrade trade;
         // ارسال درخواست تغییر پوزیشن به سرور
         if(trade.PositionModify(ticket, new_sl, PositionGetDouble(POSITION_TP)))
            Log("SL دینامیک برای تیکت " + (string)ticket + " با موفقیت به‌روزرسانی شد.");
         else
            LogError("خطا در تغییر SL دینامیک برای تیکت " + (string)ticket + ": " + (string)trade.ResultRetcode() + " - " + trade.ResultComment());
      }
   }
   // اگر منطق خروج بر اساس RRR باشد، هیچ کاری در اینجا انجام نمی‌شود.
   // چون حد سود و ضرر از ابتدا ثابت تنظیم شده و توسط سرور بروکر مدیریت می‌شود.
   else if(Inp_ExitLogic == EXIT_RRR)
   {
      Log("خروج RRR برای کنسی فعال است. مدیریت توسط سرور انجام می‌شود. تیکت: " + (string)ticket);
   }

   Log("پایان مدیریت خروج کنسی برای تیکت: " + (string)ticket);
}

// پایان گارد پیش‌پردازنده
#endif


// Logging.mqh
// نسخه بازنویسی شده توسط سقراط (Socrates) - سیستم لاگینگ بهینه و حرفه‌ای
// این سیستم از یک بافر در حافظه برای جمع‌آوری لاگ‌ها استفاده می‌کند و به صورت دسته‌ای (Batch) روی فایل می‌نویسد
// تا از عملیات مکرر و کند I/O جلوگیری شود و عملکرد اکسپرت به حداکثر برسد.

#ifndef LOGGING_MQH
#define LOGGING_MQH

#include "Settings.mqh" // فقط برای دسترسی به Inp_EnableLogging

// --- متغیرهای سراسری برای سیستم لاگ ---
string   g_log_buffer = "";             // بافر اصلی برای نگهداری پیام‌های لاگ در حافظه RAM
string   LogFileName = "ChimeraV2_Log.txt"; // نام فایل لاگ
int      g_log_handle = INVALID_HANDLE;     // هندل فایل برای عملیات نوشتن
datetime g_last_flush_time = 0;             // زمان آخرین ذخیره‌سازی روی فایل برای کنترل بازه‌های زمانی

// --- توابع اصلی سیستم لاگ ---

// تابع جدید برای نوشتن بافر روی فایل
void FlushLogBuffer()
{
   // اگر لاگ غیرفعال است یا بافر خالی است یا هندل فایل نامعتبر است، کاری انجام نده
   if(!Inp_EnableLogging || g_log_handle == INVALID_HANDLE || g_log_buffer == "")
      return;

   // نوشتن کل محتویات بافر در انتهای فایل
   FileSeek(g_log_handle, 0, SEEK_END);
   FileWriteString(g_log_handle, g_log_buffer);
   FileFlush(g_log_handle); // اطمینان از نوشته شدن فوری روی دیسک

   g_log_buffer = ""; // خالی کردن بافر پس از نوشتن
   g_last_flush_time = TimeCurrent(); // ثبت زمان ذخیره‌سازی
   // Print("بافر لاگ روی فایل ذخیره شد."); // این خط برای دیباگ خود سیستم لاگ است، می‌توانید فعالش کنید
}

// تابع راه‌اندازی اولیه سیستم لاگ
void LogInit()
{
   if (!Inp_EnableLogging) return;
   g_log_handle = FileOpen(LogFileName, FILE_WRITE|FILE_TXT|FILE_ANSI|FILE_SHARE_READ|FILE_SHARE_WRITE);
   if (g_log_handle == INVALID_HANDLE)
   {
      Print("خطای حیاتی: فایل لاگ باز نشد. کد خطا: " + (string)GetLastError());
   }
   else
   {
      // فقط یک بار در شروع، یک پیام مهم برای جدا کردن لاگ‌های هر اجرا می‌نویسیم
      string start_message = "\r\n======================================================\r\n";
      start_message += "سیستم لاگ Chimera V2.0 در تاریخ " + TimeToString(TimeCurrent(), TIME_DATE|TIME_SECONDS) + " راه‌اندازی شد.\r\n";
      start_message += "======================================================\r\n";
      FileWriteString(g_log_handle, start_message);
      FileFlush(g_log_handle);
      g_last_flush_time = TimeCurrent();
   }
}

// تابع پایان کار سیستم لاگ
void LogDeinit()
{
   if(!Inp_EnableLogging || g_log_handle == INVALID_HANDLE) return;
   
   Log("سیستم در حال توقف است. ذخیره نهایی لاگ‌ها...");
   FlushLogBuffer(); // مهم: قبل از بستن فایل، آخرین پیام‌های بافر را ذخیره می‌کنیم
   FileClose(g_log_handle);
   g_log_handle = INVALID_HANDLE;
}

// تابع اصلی برای اضافه کردن پیام به بافر لاگ
void Log(string message, bool is_error = false)
{
   if (!Inp_EnableLogging) return;
   
   // فقط رویدادهای مهم و خطاها لاگ می‌شوند
   string prefix = is_error ? "[خطا]: " : "[اطلاع]: ";
   string full_message = TimeToString(TimeCurrent(), TIME_SECONDS) + " - " + prefix + message + "\r\n";

   // به جای نوشتن مستقیم روی فایل، به بافر اضافه می‌کنیم
   g_log_buffer += full_message;

   // اگر حجم بافر خیلی زیاد شد یا خطایی رخ داد، فوراً ذخیره کن
   if(StringLen(g_log_buffer) > 2048 || is_error) // 2KB buffer
   {
      FlushLogBuffer();
   }
}

// --- توابع کمکی برای لاگ‌های استاندارد ---
// این توابع تغییری نکرده‌اند و از همان تابع Log اصلی استفاده می‌کنند.

void LogSignal(string symbol, string engine, string signal_type)
{
   Log("سیگنال جدید در نماد " + symbol + " از موتور " + engine + ": " + signal_type);
}

void LogOpenTrade(string symbol, string direction, double lots, double sl, double tp)
{
   string msg = "باز کردن معامله در " + symbol + " - جهت: " + direction + ", حجم: " + DoubleToString(lots, 2) + ", SL: " + DoubleToString(sl, _Digits) + ", TP: " + DoubleToString(tp, _Digits);
   Log(msg);
}

void LogCloseTrade(ulong ticket, string reason)
{
   string msg = "بستن معامله با تیکت " + (string)ticket + " به دلیل: " + reason;
   Log(msg);
}

void LogDrawdown(double dd)
{
   string msg = "افت سرمایه فعلی پورتفولیو: " + DoubleToString(dd * 100, 2) + "%";
   // این لاگ می‌تواند خیلی پرتکرار باشد، پس یک شرط برای جلوگیری از اسپم اضافه می‌کنیم
   static double last_logged_dd = 0;
   // فقط اگر افت سرمایه بیش از ۰.۵٪ تغییر کرده باشد لاگ کن
   if(MathAbs(dd - last_logged_dd) > 0.005)
   {
      Log(msg);
      last_logged_dd = dd;
   }
}

void LogError(string error_msg)
{
   Log(error_msg, true);
}


#endif // LOGGING_MQH

// MoneyManagement.mqh
// نسخه بازنویسی شده توسط سقراط
// این فایل مسئولیت مدیریت پول، محاسبه ریسک، و اجرای دستورات معاملاتی را بر عهده دارد.
// خطاها برطرف شده و منطق برای استحکام و خوانایی بیشتر بهینه شده است.

// جلوگیری از تکرار تعریف هدر
#ifndef MONEY_MANAGEMENT_MQH
#define MONEY_MANAGEMENT_MQH

// اینکلود فایل‌های لازم
#include "Settings.mqh" // تنظیمات ورودی و ثابت‌ها
#include "Logging.mqh"   // سیستم پیشرفته لاگینگ
#include <Trade\Trade.mqh>   // کتابخانه استاندارد MQL5 برای عملیات معاملاتی

// تعریف متغیرهای خارجی (extern) - به کامپایلر می‌گوییم این متغیرها در فایل اصلی (.mq5) تعریف شده‌اند
extern double g_peak_equity;    // برای محاسبه افت سرمایه از اوج
extern double g_Kensei_Weight;  // وزن نرمال‌شده موتور کنسی
extern double g_Hoplite_Weight; // وزن نرمال‌شده موتور هاپلیت

// --- توابع کمکی ---

// این تابع جدید جایگزین PositionSelectByMagic که وجود ندارد، می‌شود
// چک می‌کند آیا پوزیشنی با نماد و مجیک نامبر مشخصی از قبل باز است یا نه
bool PositionExists(string symbol, ulong magic_number)
{
   // حلقه از آخر به اول (روش استاندارد و امن برای کار با لیست پوزیشن‌ها)
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      // اگر بتوانیم اطلاعات پوزیشن را با ایندکس i بگیریم
      if(PositionGetTicket(i) > 0)
      {
         // چک می‌کنیم که هم نماد و هم مجیک نامبر با ورودی ما یکی باشد
         if(PositionGetString(POSITION_SYMBOL) == symbol && PositionGetInteger(POSITION_MAGIC) == magic_number)
         {
            return true; // اگر پوزیشن پیدا شد، true را برمی‌گردانیم و از تابع خارج می‌شویم
         }
      }
   }
   return false; // اگر حلقه تمام شد و چیزی پیدا نشد، یعنی پوزیشن وجود ندارد
}


// --- توابع اصلی مدیریت پول و ریسک ---

// محاسبه حجم لات بر اساس درصد ریسک و فاصله حد ضرر
double CalculateLotSize(string symbol, double risk_percent, double sl_distance_price)
{
   Log("شروع محاسبه حجم لات برای " + symbol + " با ریسک " + DoubleToString(risk_percent, 2) + "% و فاصله SL " + DoubleToString(sl_distance_price, _Digits));
   
   // گرفتن اطلاعات ضروری از نماد معاملاتی
   double lot_step = SymbolInfoDouble(symbol, SYMBOL_VOLUME_STEP);       // حداقل گام تغییر حجم (مثلا 0.01)
   double tick_value = SymbolInfoDouble(symbol, SYMBOL_TRADE_TICK_VALUE); // ارزش هر تیک حرکت قیمت
   double point = SymbolInfoDouble(symbol, SYMBOL_POINT);               // اندازه یک پوینت

   // چک کردن مقادیر برای جلوگیری از خطای تقسیم بر صفر
   if(point == 0 || tick_value == 0 || sl_distance_price <= 0)
   {
      LogError("اطلاعات نماد نامعتبر یا فاصله SL صفر برای " + symbol);
      return 0.0;
   }

   // محاسبه مقدار ریسک به پول (مثلا ۱٪ از ۱۰۰۰۰ دلار می‌شود ۱۰۰ دلار)
   double risk_amount = AccountInfoDouble(ACCOUNT_BALANCE) * risk_percent / 100.0;
   // محاسبه میزان ضرر به ازای هر ۱ لات استاندارد
   double loss_per_lot = (sl_distance_price / point) * tick_value;

   if(loss_per_lot <= 0)
   {
      LogError("میزان ضرر به ازای هر لات نامعتبر است (" + DoubleToString(loss_per_lot, 2) + ") برای " + symbol);
      return 0.0;
   }

   // محاسبه حجم لات خام و گرد کردن آن به پایین بر اساس گام مجاز نماد
   double lots = risk_amount / loss_per_lot;
   lots = MathFloor(lots / lot_step) * lot_step;
   
   Log("حجم لات نهایی محاسبه شده: " + DoubleToString(lots, 2));
   return lots;
}

// محاسبه افت سرمایه فعلی از آخرین اوج ثبت شده
double CalculateCurrentDrawdown()
{
   double equity = AccountInfoDouble(ACCOUNT_EQUITY); // موجودی شناور فعلی
   // اگر اکوییتی فعلی از اوج قبلی بیشتر باشد، اوج جدید را ثبت می‌کنیم
   if (equity > g_peak_equity) 
   {
      g_peak_equity = equity;
   }
   // محاسبه درصد افت سرمایه
   double dd = (g_peak_equity > 0) ? (g_peak_equity - equity) / g_peak_equity : 0.0;
   return dd;
}

// چک می‌کند آیا افت سرمایه از حد مجاز فراتر رفته است یا نه
bool IsPortfolioDrawdownExceeded()
{
   double current_dd = CalculateCurrentDrawdown();
   LogDrawdown(current_dd); // ثبت افت سرمایه در لاگ
   
   bool exceeded = current_dd >= Inp_MaxPortfolioDrawdown; // مقایسه با حد مجاز
   if (exceeded)
   {
      Log("!!! هشدار حیاتی: افت سرمایه از حد مجاز ("+DoubleToString(Inp_MaxPortfolioDrawdown*100, 2)+"%) فراتر رفت. مقدار فعلی: " + DoubleToString(current_dd * 100, 2) + "%");
   }
   return exceeded;
}

// تابع اصلی برای باز کردن یک معامله جدید
void OpenTrade(string symbol, SIGNAL sig, int engine_id, int atr_handle)
{
   if (sig == SIGNAL_NONE) return; // اگر سیگنالی وجود ندارد، خارج شو

   // چک کردن پوزیشن تکراری با استفاده از تابع کمکی جدید
   ulong magic_number_to_check = Inp_BaseMagicNumber + engine_id;
   if(PositionExists(symbol, magic_number_to_check))
   {
      Log("پوزیشن باز برای موتور " + (engine_id == 1 ? "Kensei" : "Hoplite") + " روی نماد " + symbol + " از قبل وجود دارد. معامله جدید باز نشد.");
      return;
   }

   Log("تلاش برای باز کردن معامله در " + symbol + " از موتور " + (engine_id == 1 ? "Kensei" : "Hoplite"));

   if (atr_handle == INVALID_HANDLE) { LogError("هندل ATR نامعتبر برای باز کردن معامله در " + symbol); return; }
   
   double atr_value[1];
   if (CopyBuffer(atr_handle, 0, 1, 1, atr_value) <= 0) { LogError("خطا در کپی ATR برای باز کردن معامله در " + symbol); return; }
   
   // محاسبه فاصله حد ضرر بر اساس موتور مربوطه
   double sl_distance = 0.0;
   if (engine_id == 1) // موتور Kensei
   {
      sl_distance = atr_value[0] * Inp_Kensei_ATR_Multiplier;
   }
   else // موتور Hoplite
   {
      sl_distance = atr_value[0] * Inp_Hoplite_StopLoss_ATR_Multiplier;
   }
   
   // استفاده از وزن نرمال‌شده که در فایل اصلی محاسبه شده
   double weight = (engine_id == 1) ? g_Kensei_Weight : g_Hoplite_Weight;
   // محاسبه درصد ریسک نهایی با استفاده از پارامتر ورودی جدید و وزن موتور
   double risk_percent = Inp_Risk_Percent_Per_Trade * weight;
   
   Log("درصد ریسک نهایی محاسبه شده: " + DoubleToString(risk_percent, 2) + "%");

   double lots = CalculateLotSize(symbol, risk_percent, sl_distance);
   if (lots <= 0) { LogError("حجم لات محاسبه شده صفر یا نامعتبر است برای " + symbol); return; }

   // تعیین مشخصات معامله
   ENUM_ORDER_TYPE dir = (sig == SIGNAL_LONG) ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
   double open_price = (dir == ORDER_TYPE_BUY) ? SymbolInfoDouble(symbol, SYMBOL_ASK) : SymbolInfoDouble(symbol, SYMBOL_BID);
   double sl = (dir == ORDER_TYPE_BUY) ? open_price - sl_distance : open_price + sl_distance;
   double tp = 0.0; // به طور پیش‌فرض حد سود نداریم (برای خروج دینامیک)
   
   // اگر منطق خروج بر اساس RRR باشد، حد سود را محاسبه می‌کنیم
   if (Inp_ExitLogic == EXIT_RRR)
   {
      tp = (dir == ORDER_TYPE_BUY) ? open_price + (sl_distance * Inp_RiskRewardRatio) : open_price - (sl_distance * Inp_RiskRewardRatio);
      Log("حد سود بر اساس RRR محاسبه شد: " + DoubleToString(tp, _Digits));
   }
   
   ulong magic = Inp_BaseMagicNumber + engine_id;
   string comment = COMMENT_PREFIX + (engine_id == 1 ? "Kensei" : "Hoplite");
   
   // اجرای معامله
   CTrade trade;
   trade.SetExpertMagicNumber(magic);
   if (trade.PositionOpen(symbol, dir, lots, open_price, sl, tp, comment))
   {
      LogOpenTrade(symbol, (sig == SIGNAL_LONG ? "خرید" : "فروش"), lots, sl, tp);
   }
   else
   {
      LogError("خطا در باز کردن معامله: " + IntegerToString(trade.ResultRetcode()) + " - " + trade.ResultComment());
   }
}

// پایان گارد
#endif

```
