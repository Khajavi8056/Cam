```mqh
// Settings.mqh
// این فایل به عنوان پنل کنترل مرکزی عمل می‌کند و تمام پارامترهای ورودی کاربر و ثابت‌های سیستم را تعریف می‌کند. این فایل برای جلوگیری از پراکندگی تنظیمات در کدهای دیگر استفاده می‌شود.

// جلوگیری از تعریف مجدد هدر فایل برای جلوگیری از خطاهای کامپایل چندباره
#ifndef SETTINGS_MQH  // اگر SETTINGS_MQH قبلاً تعریف نشده باشد
#define SETTINGS_MQH  // تعریف SETTINGS_MQH برای علامت‌گذاری اینکه این هدر قبلاً شامل شده است

// تعریف enum برای انواع منطق خروج معاملات، که به کاربر اجازه انتخاب بین خروج دینامیک یا مبتنی بر نسبت ریسک به ریوارد را می‌دهد
enum ENUM_EXIT_LOGIC  // تعریف یک نوع شمارش‌شده (enum) برای منطق خروج
{
   EXIT_DYNAMIC,    // خروج دینامیک: بر اساس اندیکاتورها مانند کیجون-سن یا خط میانی بولینگر - مناسب برای بازارهای پویا
   EXIT_RRR         // خروج مبتنی بر نسبت ریسک به ریوارد ثابت: خروج وقتی سود به نسبت مشخصی از ریسک برسد - مناسب برای استراتژی‌های ثابت
};

// تعریف enum برای انواع سیگنال‌ها، که نشان‌دهنده هیچ سیگنال، سیگنال خرید یا فروش است - این enum در موتورهای معاملاتی استفاده می‌شود
enum SIGNAL { SIGNAL_NONE, SIGNAL_LONG, SIGNAL_SHORT };  // SIGNAL_NONE: بدون سیگنال، SIGNAL_LONG: سیگنال خرید، SIGNAL_SHORT: سیگنال فروش

// بخش پارامترهای ورودی کاربر شروع می‌شود - این ورودی‌ها در پنل تنظیمات EA در متاتریدر قابل تغییر هستند
input double Inp_TotalInitialCapital = 10000.0; // سرمایه اولیه مجازی: برای محاسبه حجم معاملات و درصد افت سرمایه استفاده می‌شود - این مقدار برای شبیه‌سازی ریسک بدون تأثیر بر حساب واقعی است
input double Inp_Kensei_Weight = 0.60; // وزن تخصیص سرمایه به موتور Kensei: بین 0.0 تا 1.0 - درصد سرمایه اختصاصی به موتور تهاجمی Kensei
input double Inp_Hoplite_Weight = 0.40; // وزن تخصیص سرمایه به موتور Hoplite: بین 0.0 تا 1.0 - درصد سرمایه اختصاصی به موتور دفاعی Hoplite
input double Inp_MaxPortfolioDrawdown = 0.09; // حداکثر افت سرمایه مجاز برای کل پورتفولیو: به صورت درصد (مثلاً 0.09 یعنی 9%) - اگر افت بیشتر شود، تمام معاملات بسته می‌شوند
input ulong  Inp_BaseMagicNumber = 12345; // شماره مجیک پایه: برای تمایز معاملات این EA از سایر EAها - مجیک نامبر منحصر به فرد برای شناسایی معاملات

input string Inp_Kensei_Symbols = "EURUSD,GBPUSD,XAUUSD"; // لیست نمادهای معاملاتی برای موتور Kensei: جدا شده با کاما - نمادهایی که Kensei روی آن‌ها معامله می‌کند
input bool   Inp_Kensei_IsActive = true; // فعال‌سازی موتور Kensei: true برای فعال، false برای غیرفعال - کلید اصلی برای روشن/خاموش کردن موتور تهاجمی
input ENUM_TIMEFRAMES Inp_Kensei_Timeframe = PERIOD_H1; // تایم‌فریم عملیاتی برای Kensei: مثلاً PERIOD_H1 برای ساعتی - تایم‌فریم محاسبات اندیکاتورها
input int    Inp_Kensei_Tenkan = 9; // دوره تنکان-سن در ایچیموکو: معمولاً 9 - برای محاسبه خط تنکان-سن
input int    Inp_Kensei_Kijun = 26; // دوره کیجون-سن در ایچیموکو: معمولاً 26 - برای محاسبه خط کیجون-سن
input int    Inp_Kensei_SenkouB = 52; // دوره سنکو اسپن B در ایچیموکو: معمولاً 52 - برای محاسبه ابر کومو
input int    Inp_Kensei_ATR_Period = 14; // دوره ATR برای حد ضرر در Kensei: معمولاً 14 - برای محاسبه نوسان بازار
input double Inp_Kensei_ATR_Multiplier = 3.0; // ضریب ATR برای فاصله حد ضرر: مثلاً 3.0 - تنظیم حساسیت حد ضرر
input int    Inp_Kensei_Chikou_OpenSpace = 12; // تعداد کندل‌های گذشته برای چک فضای باز چیکو: مثلاً 12 - برای شرط ورود معامله

input string Inp_Hoplite_Symbols = "EURUSD,GBPUSD,XAUUSD"; // لیست نمادهای معاملاتی برای موتور Hoplite: جدا شده با کاما - نمادهایی که Hoplite روی آن‌ها معامله می‌کند
input bool   Inp_Hoplite_IsActive = true; // فعال‌سازی موتور Hoplite: true برای فعال، false برای غیرفعال - کلید اصلی برای روشن/خاموش کردن موتور دفاعی
input ENUM_TIMEFRAMES Inp_Hoplite_Timeframe = PERIOD_H1; // تایم‌فریم عملیاتی برای Hoplite: مثلاً PERIOD_H1 - تایم‌فریم محاسبات اندیکاتورها
input int    Inp_Hoplite_BB_Period = 20; // دوره باندهای بولینگر در Hoplite: معمولاً 20 - برای محاسبه باندها
input double Inp_Hoplite_BB_Deviation = 2.5; // انحراف استاندارد برای باندهای بولینگر: مثلاً 2.5 - تنظیم عرض باندها
input int    Inp_Hoplite_RSI_Period = 14; // دوره RSI در Hoplite: معمولاً 14 - برای محاسبه شاخص قدرت نسبی
input double Inp_Hoplite_RSI_Overbought = 75.0; // سطح اشباع خرید RSI: مثلاً 75.0 - شرط ورود فروش
input double Inp_Hoplite_RSI_Oversold = 25.0; // سطح اشباع فروش RSI: مثلاً 25.0 - شرط ورود خرید
input int    Inp_Hoplite_ADX_Period = 14; // دوره ADX در Hoplite: معمولاً 14 - برای فیلتر رژیم بازار (رونددار یا رنج)
input double Inp_Hoplite_ADX_Threshold = 25.0; // آستانه ADX برای تشخیص بازار رونددار: مثلاً 25.0 - اگر ADX بالاتر باشد، بازار رونددار است
input double Inp_Hoplite_StopLoss_ATR_Multiplier = 2.0; // ضریب ATR برای حد ضرر در Hoplite: مثلاً 2.0 - تنظیم فاصله SL

input ENUM_EXIT_LOGIC Inp_ExitLogic = EXIT_DYNAMIC; // نوع منطق خروج: EXIT_DYNAMIC یا EXIT_RRR - انتخاب روش خروج معاملات
input double Inp_RiskRewardRatio = 3.0; // نسبت ریسک به ریوارد برای خروج RRR: مثلاً 3.0 یعنی TP سه برابر SL

input bool Inp_Show_Kensei_Indicators = false; // نمایش اندیکاتورهای Kensei روی چارت: true برای نمایش - مفید برای توسعه‌دهنده
input bool Inp_Show_Hoplite_Indicators = false; // نمایش اندیکاتورهای Hoplite روی چارت: true برای نمایش - مفید برای توسعه‌دهنده
input bool Inp_Show_OnChart_Display = true; // نمایش پنل اطلاعاتی روی چارت: true برای نمایش - پنل وضعیت EA
input bool Inp_EnableLogging = true; // فعال‌سازی سیستم لاگ: true برای ثبت لاگ‌ها - مفید برای دیباگ

// بخش ثابت‌ها شروع می‌شود - این مقادیر تغییر نمی‌کنند و در سراسر کد استفاده می‌شوند
const string COMMENT_PREFIX = "[ChimeraV2] "; // پیشوند کامنت معاملات: برای شناسایی آسان معاملات این EA در لیست معاملات

#endif  // پایان گارد تعریف - پایان هدر فایل، تمام تعاریف در اینجا به پایان می‌رسد
```

```mq5
// Chimera_V2_EA.mq5
// این فایل اصلی اکسپرت است که نقش رهبر ارکستر را ایفا می‌کند و تمام اجزای سیستم را هماهنگ می‌نماید. تمام موتورها و مدیریت‌ها از اینجا فراخوانی می‌شوند.

#property copyright "Chimera V2.0"  // حقوق کپی‌رایت: نام و نسخه EA برای نمایش در متاتریدر
#property version   "2.00"  // نسخه EA: برای پیگیری تغییرات نسخه
#property strict  // حالت دقیق: فعال کردن بررسی‌های سخت‌گیرانه کامپایلر برای جلوگیری از خطاها

#include "Settings.mqh"  // شامل فایل تنظیمات: دسترسی به تمام ورودی‌ها و ثابت‌ها
#include "Logging.mqh"  // شامل فایل لاگینگ: برای ثبت رویدادها و خطاها
#include "MoneyManagement.mqh"  // شامل فایل مدیریت پول: برای محاسبه حجم و ریسک
#include "Engine_Kensei.mqh"  // شامل موتور Kensei: موتور تهاجمی روندگرا
#include "Engine_Hoplite.mqh"  // شامل موتور Hoplite: موتور دفاعی بازگشت به میانگین

// متغیرهای جهانی شروع می‌شوند - این متغیرها در سراسر EA قابل دسترسی هستند
string kensei_syms[];  // آرایه نمادهای Kensei: لیست نمادهایی که موتور Kensei روی آن‌ها کار می‌کند
datetime last_kensei_times[];  // آرایه زمان آخرین بررسی برای هر نماد Kensei: برای تشخیص بار جدید
string hoplite_syms[];  // آرایه نمادهای Hoplite: لیست نمادهایی که موتور Hoplite روی آن‌ها کار می‌کند
datetime last_hoplite_times[];  // آرایه زمان آخرین بررسی برای هر نماد Hoplite: برای تشخیص بار جدید
double g_peak_equity = 0;  // اوج اکویتی: برای محاسبه حداکثر افت سرمایه (drawdown)

// آرایه‌های هندل اندیکاتورها - هندل‌ها یک بار ساخته می‌شوند تا عملکرد بهینه شود
int g_kensei_ichi_handles[];  // آرایه هندل‌های ایچیموکو برای نمادهای Kensei: ذخیره هندل‌ها برای دسترسی سریع
int g_kensei_atr_handles[];  // آرایه هندل‌های ATR برای نمادهای Kensei: ذخیره هندل‌ها
int g_hoplite_bb_handles[];  // آرایه هندل‌های بولینگر باند برای نمادهای Hoplite: ذخیره هندل‌ها
int g_hoplite_rsi_handles[];  // آرایه هندل‌های RSI برای نمادهای Hoplite: ذخیره هندل‌ها
int g_hoplite_adx_handles[];  // آرایه هندل‌های ADX برای نمادهای Hoplite: ذخیره هندل‌ها
int g_hoplite_atr_handles[];  // آرایه هندل‌های ATR برای نمادهای Hoplite: ذخیره هندل‌ها

// تابع OnInit: این تابع هنگام شروع EA فراخوانی می‌شود و تمام ابتدایی‌سازی‌ها را انجام می‌دهد
int OnInit()  // بازگشت int: INIT_SUCCEEDED برای موفقیت، INIT_FAILED برای شکست
{
   Log("شروع اکسپرت Chimera V2.0");  // ثبت لاگ شروع EA: برای اطلاع از راه‌اندازی موفق
   LogInit();  // فراخوانی تابع ابتدایی‌سازی لاگ: باز کردن فایل لاگ
   int kensei_count = StringSplit(Inp_Kensei_Symbols, ',', kensei_syms);  // تقسیم لیست نمادهای Kensei به آرایه: تعداد نمادها را برمی‌گرداند
   if (kensei_count <= 0) { LogError("خطا در تقسیم نمادهای Kensei: " + Inp_Kensei_Symbols); return INIT_FAILED; }  // چک خطا در تقسیم: اگر شکست، EA را متوقف کن
   ArrayResize(last_kensei_times, kensei_count);  // تغییر اندازه آرایه زمان‌ها به تعداد نمادها: برای ذخیره زمان آخرین چک هر نماد
   ArrayInitialize(last_kensei_times, 0);  // مقداردهی اولیه آرایه زمان‌ها به 0: یعنی هیچ چک قبلی وجود ندارد
   int hoplite_count = StringSplit(Inp_Hoplite_Symbols, ',', hoplite_syms);  // تقسیم لیست نمادهای Hoplite به آرایه: مشابه Kensei
   if (hoplite_count <= 0) { LogError("خطا در تقسیم نمادهای Hoplite: " + Inp_Hoplite_Symbols); return INIT_FAILED; }  // چک خطا در تقسیم Hoplite
   ArrayResize(last_hoplite_times, hoplite_count);  // تغییر اندازه آرایه زمان‌ها برای Hoplite
   ArrayInitialize(last_hoplite_times, 0);  // مقداردهی اولیه به 0
   // ابتدایی‌سازی هندل‌های Kensei شروع می‌شود
   ArrayResize(g_kensei_ichi_handles, kensei_count);  // تغییر اندازه آرایه هندل ایچیموکو به تعداد نمادها
   ArrayResize(g_kensei_atr_handles, kensei_count);  // تغییر اندازه آرایه هندل ATR
   for (int i = 0; i < kensei_count; i++)  // لوپ روی تمام نمادهای Kensei: برای ایجاد هندل هر نماد
   {
      g_kensei_ichi_handles[i] = iIchimoku(kensei_syms[i], Inp_Kensei_Timeframe, Inp_Kensei_Tenkan, Inp_Kensei_Kijun, Inp_Kensei_SenkouB);  // ایجاد هندل ایچیموکو برای نماد فعلی
      g_kensei_atr_handles[i] = iATR(kensei_syms[i], Inp_Kensei_Timeframe, Inp_Kensei_ATR_Period);  // ایجاد هندل ATR برای نماد فعلی
      if (g_kensei_ichi_handles[i] == INVALID_HANDLE || g_kensei_atr_handles[i] == INVALID_HANDLE)  // چک validity هندل‌ها: اگر نامعتبر، خطا
      {
         LogError("خطا در ایجاد هندل Kensei برای نماد: " + kensei_syms[i]);  // ثبت خطا
         return INIT_FAILED;  // بازگشت شکست ابتدایی‌سازی
      }
   }
   // ابتدایی‌سازی هندل‌های Hoplite شروع می‌شود
   ArrayResize(g_hoplite_bb_handles, hoplite_count);  // تغییر اندازه آرایه هندل BB
   ArrayResize(g_hoplite_rsi_handles, hoplite_count);  // تغییر اندازه آرایه هندل RSI
   ArrayResize(g_hoplite_adx_handles, hoplite_count);  // تغییر اندازه آرایه هندل ADX
   ArrayResize(g_hoplite_atr_handles, hoplite_count);  // تغییر اندازه آرایه هندل ATR
   for (int i = 0; i < hoplite_count; i++)  // لوپ روی تمام نمادهای Hoplite
   {
      g_hoplite_bb_handles[i] = iBands(hoplite_syms[i], Inp_Hoplite_Timeframe, Inp_Hoplite_BB_Period, 0, Inp_Hoplite_BB_Deviation, PRICE_CLOSE);  // ایجاد هندل BB
      g_hoplite_rsi_handles[i] = iRSI(hoplite_syms[i], Inp_Hoplite_Timeframe, Inp_Hoplite_RSI_Period, PRICE_CLOSE);  // ایجاد هندل RSI
      g_hoplite_adx_handles[i] = iADX(hoplite_syms[i], Inp_Hoplite_Timeframe, Inp_Hoplite_ADX_Period);  // ایجاد هندل ADX
      g_hoplite_atr_handles[i] = iATR(hoplite_syms[i], Inp_Hoplite_Timeframe, 14);  // ایجاد هندل ATR با دوره ثابت 14
      if (g_hoplite_bb_handles[i] == INVALID_HANDLE || g_hoplite_rsi_handles[i] == INVALID_HANDLE || g_hoplite_adx_handles[i] == INVALID_HANDLE || g_hoplite_atr_handles[i] == INVALID_HANDLE)  // چک validity
      {
         LogError("خطا در ایجاد هندل Hoplite برای نماد: " + hoplite_syms[i]);  // ثبت خطا
         return INIT_FAILED;  // بازگشت شکست
      }
   }
   if (Inp_Show_Kensei_Indicators)  // اگر نمایش اندیکاتورهای Kensei فعال باشد
   {
      iIchimoku(_Symbol, Inp_Kensei_Timeframe, Inp_Kensei_Tenkan, Inp_Kensei_Kijun, Inp_Kensei_SenkouB);  // اضافه کردن ایچیموکو به چارت فعلی
      Log("اندیکاتورهای Kensei نمایش داده شد");  // ثبت لاگ نمایش
   }
   if (Inp_Show_Hoplite_Indicators)  // اگر نمایش اندیکاتورهای Hoplite فعال باشد
   {
      iBands(_Symbol, Inp_Hoplite_Timeframe, Inp_Hoplite_BB_Period, 0, Inp_Hoplite_BB_Deviation, PRICE_CLOSE);  // اضافه کردن BB به چارت
      iRSI(_Symbol, Inp_Hoplite_Timeframe, Inp_Hoplite_RSI_Period, PRICE_CLOSE);  // اضافه کردن RSI به چارت
      iADX(_Symbol, Inp_Hoplite_Timeframe, Inp_Hoplite_ADX_Period);  // اضافه کردن ADX به چارت
      Log("اندیکاتورهای Hoplite نمایش داده شد");  // ثبت لاگ نمایش
   }
   if (Inp_Show_OnChart_Display)  // اگر نمایش پنل روی چارت فعال باشد
   {
      Log("پنل اطلاعاتی روی چارت نمایش داده شد");  // ثبت لاگ (پیاده‌سازی پنل در کد فرض شده است)
   }
   g_peak_equity = AccountInfoDouble(ACCOUNT_EQUITY);  // تنظیم اوج اکویتی اولیه بر اساس اکویتی فعلی حساب
   Log("اوج اکویتی اولیه تنظیم شد: " + DoubleToString(g_peak_equity, 2));  // ثبت لاگ مقدار اولیه
   EventSetTimer(1);  // تنظیم تایمر برای فراخوانی OnTimer هر 1 ثانیه: برای چک دوره‌ای
   return(INIT_SUCCEEDED);  // بازگشت موفقیت ابتدایی‌سازی: EA آماده کار است
}

// تابع OnDeinit: این تابع هنگام توقف EA فراخوانی می‌شود و منابع را آزاد می‌کند
void OnDeinit(const int reason)  // پارامتر reason: دلیل توقف (مثلاً تغییر تنظیمات)
{
   Log("پایان اکسپرت Chimera V2.0 با دلیل: " + IntegerToString(reason));  // ثبت لاگ پایان با دلیل
   EventKillTimer();  // خاموش کردن تایمر: جلوگیری از فراخوانی‌های بیشتر
   // آزاد کردن هندل‌های Kensei شروع می‌شود
   for (int i = 0; i < ArraySize(g_kensei_ichi_handles); i++)  // لوپ روی تمام هندل‌های Kensei
   {
      if (g_kensei_ichi_handles[i] != INVALID_HANDLE) IndicatorRelease(g_kensei_ichi_handles[i]);  // آزاد کردن هندل ایچیموکو اگر معتبر باشد
      if (g_kensei_atr_handles[i] != INVALID_HANDLE) IndicatorRelease(g_kensei_atr_handles[i]);  // آزاد کردن هندل ATR
   }
   // آزاد کردن هندل‌های Hoplite
   for (int i = 0; i < ArraySize(g_hoplite_bb_handles); i++)  // لوپ روی تمام هندل‌های Hoplite
   {
      if (g_hoplite_bb_handles[i] != INVALID_HANDLE) IndicatorRelease(g_hoplite_bb_handles[i]);  // آزاد کردن هندل BB
      if (g_hoplite_rsi_handles[i] != INVALID_HANDLE) IndicatorRelease(g_hoplite_rsi_handles[i]);  // آزاد کردن هندل RSI
      if (g_hoplite_adx_handles[i] != INVALID_HANDLE) IndicatorRelease(g_hoplite_adx_handles[i]);  // آزاد کردن هندل ADX
      if (g_hoplite_atr_handles[i] != INVALID_HANDLE) IndicatorRelease(g_hoplite_atr_handles[i]);  // آزاد کردن هندل ATR
   }
   LogDeinit();  // فراخوانی تابع پایان لاگ: بستن فایل لاگ
}

// تابع OnTimer: این تابع هر 1 ثانیه فراخوانی می‌شود و چک‌های دوره‌ای را انجام می‌دهد
void OnTimer()  // بدون پارامتر و بازگشت void: فقط عملیات چک را انجام می‌دهد
{
   Log("چک تایمر - بررسی وضعیت پورتفولیو و سیگنال‌ها");  // ثبت لاگ هر چک تایمر
   if (IsPortfolioDrawdownExceeded())  // چک اگر افت سرمایه بیش از حد مجاز باشد
   {
      Log("افت سرمایه بیش از حد - بستن تمام موقعیت‌ها");  // ثبت لاگ هشدار
      CloseAllPositions();  // فراخوانی تابع بستن تمام موقعیت‌ها
      return;  // خروج زودرس از تابع: اگر DD بیش از حد، بقیه چک‌ها را انجام نده
   }
   if (Inp_Kensei_IsActive)  // اگر موتور Kensei فعال باشد
   {
      for (int i = 0; i < ArraySize(kensei_syms); i++)  // لوپ روی تمام نمادهای Kensei
      {
         datetime current_time = iTime(kensei_syms[i], Inp_Kensei_Timeframe, 0);  // دریافت زمان کندل فعلی نماد
         if (current_time > last_kensei_times[i])  // چک اگر بار جدید تشکیل شده باشد (زمان جدید > زمان آخرین)
         {
            Log("بار جدید در تایم‌فریم Kensei برای نماد " + kensei_syms[i]);  // ثبت لاگ بار جدید
            last_kensei_times[i] = current_time;  // بروزرسانی زمان آخرین چک
            SIGNAL sig = GetKenseiSignal(kensei_syms[i], g_kensei_ichi_handles[i], g_kensei_atr_handles[i]);  // دریافت سیگنال از موتور Kensei
            OpenTrade(kensei_syms[i], sig, 1, g_kensei_atr_handles[i]);  // باز کردن معامله اگر سیگنال وجود داشته باشد (1 برای ID موتور Kensei)
         }
      }
   }
   if (Inp_Hoplite_IsActive)  // اگر موتور Hoplite فعال باشد
   {
      for (int i = 0; i < ArraySize(hoplite_syms); i++)  // لوپ روی تمام نمادهای Hoplite
      {
         datetime current_time = iTime(hoplite_syms[i], Inp_Hoplite_Timeframe, 0);  // دریافت زمان کندل فعلی
         if (current_time > last_hoplite_times[i])  // چک بار جدید
         {
            Log("بار جدید در تایم‌فریم Hoplite برای نماد " + hoplite_syms[i]);  // ثبت لاگ
            last_hoplite_times[i] = current_time;  // بروزرسانی زمان
            SIGNAL sig = GetHopliteSignal(hoplite_syms[i], g_hoplite_bb_handles[i], g_hoplite_rsi_handles[i], g_hoplite_adx_handles[i]);  // دریافت سیگنال از Hoplite
            OpenTrade(hoplite_syms[i], sig, 2, g_hoplite_atr_handles[i]);  // باز کردن معامله (2 برای ID موتور Hoplite)
         }
      }
   }
   ManageTrades();  // فراخوانی مدیریت معاملات موجود: چک خروج‌ها و بروزرسانی‌ها
}

// تابع ManageTrades: مدیریت معاملات باز، مانند چک شرط خروج
void ManageTrades()  // بدون پارامتر، فقط لوپ روی موقعیت‌ها
{
   Log("شروع مدیریت معاملات موجود");  // ثبت لاگ شروع مدیریت
   for (int i = PositionsTotal() - 1; i >= 0; i--)  // لوپ معکوس روی تمام موقعیت‌ها: از آخر به اول برای ایمنی در بستن
   {
      ulong ticket = PositionGetTicket(i);  // دریافت تیکت موقعیت i
      if (ticket == 0) continue;  // اگر تیکت نامعتبر، رد شو به موقعیت بعدی
      ulong magic = PositionGetInteger(POSITION_MAGIC);  // دریافت مجیک نامبر موقعیت
      string symbol = PositionGetString(POSITION_SYMBOL);  // دریافت نماد موقعیت
      if (magic == Inp_BaseMagicNumber + 1)  // اگر مجیک مربوط به Kensei باشد
      {
         int sym_index = -1;  // ایندکس اولیه -1 (یعنی یافت نشد)
         for (int j = 0; j < ArraySize(kensei_syms); j++)  // لوپ برای پیدا کردن ایندکس نماد در لیست Kensei
         {
            if (kensei_syms[j] == symbol) { sym_index = j; break; }  // اگر یافت شد، ایندکس را تنظیم کن و لوپ را قطع کن
         }
         if (sym_index != -1)  // اگر نماد یافت شد
         {
            ManageKenseiExit(ticket, g_kensei_ichi_handles[sym_index]);  // فراخوانی مدیریت خروج Kensei با تیکت و هندل مربوطه
         }
         else
         {
            LogError("نماد " + symbol + " در لیست Kensei یافت نشد برای تیکت " + IntegerToString(ticket));  // ثبت خطا اگر نماد یافت نشود
         }
      }
      else if (magic == Inp_BaseMagicNumber + 2)  // اگر مجیک مربوط به Hoplite باشد
      {
         int sym_index = -1;  // ایندکس اولیه -1
         for (int j = 0; j < ArraySize(hoplite_syms); j++)  // لوپ برای پیدا کردن ایندکس در لیست Hoplite
         {
            if (hoplite_syms[j] == symbol) { sym_index = j; break; }  // تنظیم ایندکس اگر یافت شد
         }
         if (sym_index != -1)  // اگر یافت شد
         {
            ManageHopliteExit(ticket, g_hoplite_bb_handles[sym_index]);  // فراخوانی مدیریت خروج Hoplite
         }
         else
         {
            LogError("نماد " + symbol + " در لیست Hoplite یافت نشد برای تیکت " + IntegerToString(ticket));  // ثبت خطا
         }
      }
   }
   Log("پایان مدیریت معاملات");  // ثبت لاگ پایان مدیریت
}

// تابع CloseAllPositions: بستن تمام موقعیت‌های باز در موارد اضطراری مانند DD بیش از حد
void CloseAllPositions()  // بدون پارامتر، لوپ روی موقعیت‌ها و بستن آن‌ها
{
   Log("شروع بستن تمام موقعیت‌ها");  // ثبت لاگ شروع
   CTrade trade;  // ایجاد شیء CTrade: برای عملیات معاملاتی مانند بستن
   for (int i = PositionsTotal() - 1; i >= 0; i--)  // لوپ معکوس روی موقعیت‌ها
   {
      ulong ticket = PositionGetTicket(i);  // دریافت تیکت
      if (ticket == 0) continue;  // رد اگر نامعتبر
      string symbol = PositionGetString(POSITION_SYMBOL);  // دریافت نماد
      long type = PositionGetInteger(POSITION_TYPE);  // دریافت نوع موقعیت (خرید یا فروش)
      double close_price = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(symbol, SYMBOL_BID) : SymbolInfoDouble(symbol, SYMBOL_ASK);  // تعیین قیمت بستن بر اساس نوع
      if (trade.PositionClose(ticket, 3))  // تلاش برای بستن موقعیت با slippage 3
         LogCloseTrade(ticket, "افت سرمایه بیش از حد");  // ثبت لاگ موفقیت بستن
      else
         LogError("خطا در بستن موقعیت تیکت " + IntegerToString(ticket) + ": " + IntegerToString(trade.ResultRetcode()));  // ثبت خطا با کد بازگشت
   }
   Log("پایان بستن موقعیت‌ها");  // ثبت لاگ پایان
}
```

```mqh
// Engine_Hoplite.mqh
// این فایل موتور دفاعی Hoplite را پیاده‌سازی می‌کند که بر اساس استراتژی بازگشت به میانگین کار می‌کند. شامل تولید سیگنال و مدیریت خروج است.

#ifndef ENGINE_HOPLITE_MQH  // جلوگیری از تعریف مجدد هدر
#define ENGINE_HOPLITE_MQH  // تعریف گارد

#include "Settings.mqh"  // شامل تنظیمات: دسترسی به ورودی‌ها مانند دوره‌ها و سطوح
#include "Logging.mqh"  // شامل لاگینگ: برای ثبت رویدادها و سیگنال‌ها
#include "MoneyManagement.mqh"  // شامل مدیریت پول: برای محاسبات ریسک در خروج
#include "Engine_Kensei.mqh"  // شامل موتور Kensei: برای وابستگی‌های احتمالی (اگر لازم باشد)

// تابع GetHopliteSignal: تولید سیگنال بر اساس اندیکاتورهای BB، RSI و ADX - هندل‌ها را دریافت می‌کند تا از بازسازی اندیکاتور جلوگیری شود
SIGNAL GetHopliteSignal(string symbol, int bb_handle, int rsi_handle, int adx_handle)  // پارامترها: نماد و هندل اندیکاتورها - بازگشت SIGNAL
{
   Log("شروع بررسی سیگنال Hoplite برای نماد: " + symbol);  // ثبت لاگ شروع بررسی: برای پیگیری فرآیند
   if (bb_handle == INVALID_HANDLE) { LogError("هندل BB نامعتبر برای " + symbol); return SIGNAL_NONE; }  // چک هندل BB: اگر نامعتبر، بدون سیگنال و خطا
   if (rsi_handle == INVALID_HANDLE) { LogError("هندل RSI نامعتبر برای " + symbol); return SIGNAL_NONE; }  // چک هندل RSI
   if (adx_handle == INVALID_HANDLE) { LogError("هندل ADX نامعتبر برای " + symbol); return SIGNAL_NONE; }  // چک هندل ADX
   double bb_upper[1], bb_lower[1], bb_mid[1];  // بافرهای تک‌عنصری برای باندهای بولینگر: برای ذخیره مقادیر فعلی
   double rsi[1], adx[1];  // بافرهای RSI و ADX: برای مقادیر فعلی
   double close[1];  // بافر قیمت بسته فعلی: برای چک شرط‌ها
   if (CopyBuffer(bb_handle, 0, 0, 1, bb_mid) <= 0) { LogError("خطا در کپی BB میانی برای " + symbol); return SIGNAL_NONE; }  // کپی خط میانی BB: اگر شکست، بدون سیگنال
   if (CopyBuffer(bb_handle, 1, 0, 1, bb_upper) <= 0) { LogError("خطا در کپی BB بالایی برای " + symbol); return SIGNAL_NONE; }  // کپی باند بالایی
   if (CopyBuffer(bb_handle, 2, 0, 1, bb_lower) <= 0) { LogError("خطا در کپی BB پایینی برای " + symbol); return SIGNAL_NONE; }  // کپی باند پایینی
   if (CopyBuffer(rsi_handle, 0, 1, 1, rsi) <= 0) { LogError("خطا در کپی RSI برای " + symbol); return SIGNAL_NONE; }  // کپی مقدار RSI (کندل قبلی برای جلوگیری از lookahead)
   if (CopyBuffer(adx_handle, 0, 1, 1, adx) <= 0) { LogError("خطا در کپی ADX برای " + symbol); return SIGNAL_NONE; }  // کپی مقدار ADX
   if (CopyClose(symbol, Inp_Hoplite_Timeframe, 0, 1, close) < 1) { LogError("خطا در کپی قیمت بسته فعلی برای " + symbol); return SIGNAL_NONE; }  // کپی قیمت بسته فعلی
   if (adx[0] >= Inp_Hoplite_ADX_Threshold)  // چک فیلتر رژیم بازار: اگر ADX بالا، بازار رونددار است و سیگنال نده
   {
      Log("بازار رونددار تشخیص داده شد (ADX بالا) - بدون سیگنال برای " + symbol);  // ثبت لاگ فیلتر
      return SIGNAL_NONE;  // بازگشت بدون سیگنال
   }
   if (close[0] < bb_lower[0] && rsi[0] < Inp_Hoplite_RSI_Oversold)  // شرط سیگنال خرید: قیمت زیر باند پایین و RSI در اشباع فروش
   {
      LogSignal(symbol, "Hoplite", "خرید");  // ثبت لاگ سیگنال خرید
      return SIGNAL_LONG;  // بازگشت سیگنال خرید
   }
   if (close[0] > bb_upper[0] && rsi[0] > Inp_Hoplite_RSI_Overbought)  // شرط سیگنال فروش: قیمت بالای باند بالا و RSI در اشباع خرید
   {
      LogSignal(symbol, "Hoplite", "فروش");  // ثبت لاگ سیگنال فروش
      return SIGNAL_SHORT;  // بازگشت سیگنال فروش
   }
   Log("هیچ سیگنالی در Hoplite برای " + symbol);  // ثبت لاگ عدم سیگنال
   return SIGNAL_NONE;  // بازگشت بدون سیگنال اگر هیچ شرطی برقرار نباشد
}

// تابع ManageHopliteExit: مدیریت خروج معاملات Hoplite بر اساس منطق انتخابی - هندل BB را دریافت می‌کند
void ManageHopliteExit(ulong ticket, int bb_handle)  // پارامترها: تیکت معامله و هندل BB
{
   Log("شروع مدیریت خروج Hoplite برای تیکت: " + IntegerToString(ticket));  // ثبت لاگ شروع
   if (!PositionSelectByTicket(ticket)) { LogError("خطا در انتخاب موقعیت برای خروج Hoplite"); return; }  // انتخاب موقعیت توسط تیکت: اگر شکست، خطا و خروج
   string symbol = PositionGetString(POSITION_SYMBOL);  // دریافت نماد موقعیت
   long type = PositionGetInteger(POSITION_TYPE);  // دریافت نوع موقعیت (POSITION_TYPE_BUY یا POSITION_TYPE_SELL)
   if (Inp_ExitLogic == EXIT_DYNAMIC)  // اگر منطق خروج دینامیک انتخاب شده باشد
   {
      if (bb_handle == INVALID_HANDLE) { LogError("هندل BB نامعتبر برای خروج در " + symbol); return; }  // چک هندل BB
      double bb_mid[1];  // بافر برای خط میانی BB فعلی
      if (CopyBuffer(bb_handle, 0, 0, 1, bb_mid) <= 0) { LogError("خطا در کپی BB برای خروج در " + symbol); return; }  // کپی خط میانی
      double current_price = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(symbol, SYMBOL_BID) : SymbolInfoDouble(symbol, SYMBOL_ASK);  // قیمت فعلی بازار بر اساس نوع
      bool close_cond = (type == POSITION_TYPE_BUY && current_price >= bb_mid[0]) || (type == POSITION_TYPE_SELL && current_price <= bb_mid[0]);  // شرط بستن: رسیدن به خط میانی
      if (close_cond)  // اگر شرط برقرار باشد
      {
         CTrade trade;  // ایجاد شیء CTrade برای بستن
         if (trade.PositionClose(ticket, 3))  // بستن موقعیت با slippage 3
            LogCloseTrade(ticket, "رسیدن به خط میانی BB");  // ثبت لاگ موفقیت
         else
            LogError("خطا در بستن موقعیت دینامیک برای تیکت " + IntegerToString(ticket) + ": " + IntegerToString(trade.ResultRetcode()));  // ثبت خطا
      }
      else
      {
         Log("شرط بستن دینامیک برای تیکت " + IntegerToString(ticket) + " برقرار نیست.");  // ثبت لاگ عدم شرط
      }
   }
   else if (Inp_ExitLogic == EXIT_RRR)  // اگر منطق خروج RRR باشد
   {
      Log("خروج RRR برای Hoplite - چک TP برای تیکت " + IntegerToString(ticket));  // ثبت لاگ (چک TP در کد دیگر پیاده‌سازی می‌شود)
   }
   Log("پایان مدیریت خروج Hoplite برای تیکت: " + IntegerToString(ticket));  // ثبت لاگ پایان
}

#endif  // پایان گارد تعریف
```

```mqh
// Engine_Kensei.mqh
// این فایل موتور تهاجمی Kensei را پیاده‌سازی می‌کند که بر اساس ایچیموکو روندگرا است. شامل تولید سیگنال و مدیریت خروج.

#ifndef ENGINE_KENSEI_MQH  // جلوگیری از تعریف مجدد
#define ENGINE_KENSEI_MQH  // تعریف گارد

#include "Settings.mqh"  // شامل تنظیمات: دوره‌های ایچیموکو و ATR
#include "Logging.mqh"  // شامل لاگینگ: ثبت سیگنال‌ها و خطاها
#include "MoneyManagement.mqh"  // شامل مدیریت پول: برای خروج دینامیک SL
#include "Engine_Hoplite.mqh"  // شامل موتور Hoplite: برای وابستگی‌های احتمالی

// تابع GetKenseiSignal: تولید سیگنال بر اساس شرایط ایچیموکو - هندل‌ها را دریافت می‌کند
SIGNAL GetKenseiSignal(string symbol, int ichi_handle, int atr_handle)  // پارامترها: نماد، هندل ایچیموکو و ATR
{
   Log("شروع بررسی سیگنال Kensei برای نماد: " + symbol);  // ثبت لاگ شروع
   if (ichi_handle == INVALID_HANDLE) { LogError("هندل ایچیموکو نامعتبر است برای " + symbol); return SIGNAL_NONE; }  // چک هندل ایچیموکو
   if (atr_handle == INVALID_HANDLE) { LogError("هندل ATR نامعتبر است برای " + symbol); return SIGNAL_NONE; }  // چک هندل ATR
   double tenkan[1], kijun[1], ssa[2], ssb[2];  // بافرها برای خطوط ایچیموکو: فعلی و قبلی برای چک شکست
   double atr[1];  // بافر ATR: برای نوسان (هرچند اینجا استفاده نمی‌شود، اما هندل دریافت شده)
   if (CopyBuffer(ichi_handle, 0, 1, 1, tenkan) <= 0) { LogError("خطا در کپی تنکان برای " + symbol); return SIGNAL_NONE; }  // کپی تنکان فعلی
   if (CopyBuffer(ichi_handle, 1, 1, 1, kijun) <= 0) { LogError("خطا در کپی کیجون برای " + symbol); return SIGNAL_NONE; }  // کپی کیجون فعلی
   if (CopyBuffer(ichi_handle, 2, 0, 2, ssa) <= 0) { LogError("خطا در کپی SSA برای " + symbol); return SIGNAL_NONE; }  // کپی SSA فعلی و قبلی
   if (CopyBuffer(ichi_handle, 3, 0, 2, ssb) <= 0) { LogError("خطا در کپی SSB برای " + symbol); return SIGNAL_NONE; }  // کپی SSB فعلی و قبلی
   if (CopyBuffer(atr_handle, 0, 1, 1, atr) <= 0) { LogError("خطا در کپی ATR برای " + symbol); return SIGNAL_NONE; }  // کپی ATR (کندل قبلی)
   double close[2];  // بافر قیمت بسته: فعلی و قبلی برای چک شکست ابر
   if (CopyClose(symbol, Inp_Kensei_Timeframe, 0, 2, close) < 2) { LogError("خطا در کپی قیمت بسته برای " + symbol); return SIGNAL_NONE; }  // کپی closes
   double past_closes[27];  // بافر قیمت‌های گذشته: برای محاسبه چیکو (26 کندل قبل + فعلی)
   if (CopyClose(symbol, Inp_Kensei_Timeframe, 0, 27, past_closes) < 27) { LogError("خطا در کپی قیمت‌های گذشته برای چیکو در " + symbol); return SIGNAL_NONE; }  // کپی گذشته‌ها
   double chikou_value = past_closes[0];  // مقدار چیکو: برابر قیمت بسته فعلی (برای چک با 26 کندل قبل)
   double past_highs[];  // آرایه بالاترین قیمت‌ها: برای چک فضای باز چیکو
   double past_lows[];  // آرایه پایین‌ترین قیمت‌ها: برای چک فضای باز
   ArrayResize(past_highs, Inp_Kensei_Chikou_OpenSpace);  // تغییر اندازه آرایه به تعداد مشخص‌شده در ورودی
   ArrayResize(past_lows, Inp_Kensei_Chikou_OpenSpace);  // تغییر اندازه آرایه lows
   if (CopyHigh(symbol, Inp_Kensei_Timeframe, Inp_Kensei_Kijun, Inp_Kensei_Chikou_OpenSpace, past_highs) < Inp_Kensei_Chikou_OpenSpace) { LogError("خطا در کپی بالاترین‌ها برای فضای باز چیکو در " + symbol); return SIGNAL_NONE; }  // کپی highs از کیجون به عقب
   if (CopyLow(symbol, Inp_Kensei_Timeframe, Inp_Kensei_Kijun, Inp_Kensei_Chikou_OpenSpace, past_lows) < Inp_Kensei_Chikou_OpenSpace) { LogError("خطا در کپی پایین‌ترین‌ها برای فضای باز چیکو در " + symbol); return SIGNAL_NONE; }  // کپی lows
   double future_ssa[1], future_ssb[1];  // بافر ابر آینده: برای چک صعودی/نزولی بودن ابر آینده
   if (CopyBuffer(ichi_handle, 2, -Inp_Kensei_Kijun, 1, future_ssa) <= 0) { LogError("خطا در کپی SSA آینده برای " + symbol); return SIGNAL_NONE; }  // کپی SSA آینده (منفی برای آینده)
   if (CopyBuffer(ichi_handle, 3, -Inp_Kensei_Kijun, 1, future_ssb) <= 0) { LogError("خطا در کپی SSB آینده برای " + symbol); return SIGNAL_NONE; }  // کپی SSB آینده
   bool long_cond1 = close[0] > MathMax(ssa[0], ssb[0]) && close[1] <= MathMax(ssa[1], ssb[1]);  // شرط 1 خرید: شکست ابر به بالا (فعلی بالای ابر، قبلی زیر یا داخل)
   bool long_cond2 = future_ssa[0] > future_ssb[0];  // شرط 2 خرید: ابر آینده صعودی
   bool long_cond3 = chikou_value > past_closes[26];  // شرط 3 خرید: چیکو بالای قیمت 26 کندل قبل
   bool long_cond4 = chikou_value > ArrayMaximum(past_highs, 0, WHOLE_ARRAY);  // شرط 4 خرید: فضای باز چیکو (بالای حداکثر highs گذشته)
   if (long_cond1 && long_cond2 && long_cond3 && long_cond4)  // اگر تمام شرط‌های خرید برقرار باشد
   {
      LogSignal(symbol, "Kensei", "خرید");  // ثبت لاگ سیگنال
      return SIGNAL_LONG;  // بازگشت سیگنال خرید
   }
   bool short_cond1 = close[0] < MathMin(ssa[0], ssb[0]) && close[1] >= MathMin(ssa[1], ssb[1]);  // شرط 1 فروش: شکست ابر به پایین
   bool short_cond2 = future_ssa[0] < future_ssb[0];  // شرط 2 فروش: ابر آینده نزولی
   bool short_cond3 = chikou_value < past_closes[26];  // شرط 3 فروش: چیکو پایین قیمت 26 کندل قبل
   bool short_cond4 = chikou_value < ArrayMinimum(past_lows, 0, WHOLE_ARRAY);  // شرط 4 فروش: فضای باز چیکو (پایین حداقل lows گذشته)
   if (short_cond1 && short_cond2 && short_cond3 && short_cond4)  // اگر تمام شرط‌های فروش برقرار باشد
   {
      LogSignal(symbol, "Kensei", "فروش");  // ثبت لاگ
      return SIGNAL_SHORT;  // بازگشت سیگنال فروش
   }
   Log("هیچ سیگنالی در Kensei برای " + symbol);  // ثبت لاگ عدم سیگنال
   return SIGNAL_NONE;  // بازگشت بدون سیگنال
}

// تابع ManageKenseiExit: مدیریت خروج معاملات Kensei بر اساس منطق - هندل ایچیموکو را دریافت می‌کند
void ManageKenseiExit(ulong ticket, int ichi_handle)  // پارامترها: تیکت و هندل ایچیموکو
{
   Log("شروع مدیریت خروج Kensei برای تیکت: " + IntegerToString(ticket));  // ثبت لاگ شروع
   if (!PositionSelectByTicket(ticket)) { LogError("خطا در انتخاب موقعیت برای خروج Kensei"); return; }  // انتخاب موقعیت: اگر شکست، خطا
   string symbol = PositionGetString(POSITION_SYMBOL);  // دریافت نماد
   long type = PositionGetInteger(POSITION_TYPE);  // دریافت نوع (خرید/فروش)
   if (Inp_ExitLogic == EXIT_DYNAMIC)  // اگر خروج دینامیک
   {
      if (ichi_handle == INVALID_HANDLE) { LogError("هندل ایچیموکو نامعتبر برای خروج در " + symbol); return; }  // چک هندل
      double kijun[1];  // بافر کیجون فعلی
      if (CopyBuffer(ichi_handle, 1, 1, 1, kijun) <= 0) { LogError("خطا در کپی کیجون برای خروج در " + symbol); return; }  // کپی کیجون (کندل قبلی)
      double current_sl = PositionGetDouble(POSITION_SL);  // دریافت SL فعلی موقعیت
      double new_sl = kijun[0];  // SL جدید بر اساس کیجون
      bool modify = false;  // فلگ برای تصمیم‌گیری اصلاح SL
      if (type == POSITION_TYPE_BUY && new_sl > current_sl) modify = true;  // برای خرید: اگر کیجون بالاتر از SL فعلی، بروزرسانی
      else if (type == POSITION_TYPE_SELL && new_sl < current_sl && new_sl > 0) modify = true;  // برای فروش: اگر کیجون پایین‌تر، بروزرسانی
      if (modify)  // اگر نیاز به اصلاح باشد
      {
         CTrade trade;  // ایجاد CTrade برای اصلاح
         if (trade.PositionModify(ticket, new_sl, PositionGetDouble(POSITION_TP)))  // اصلاح SL (TP بدون تغییر)
            Log("به‌روزرسانی SL دینامیک برای تیکت " + IntegerToString(ticket) + " به " + DoubleToString(new_sl, _Digits));  // ثبت موفقیت
         else 
            LogError("خطا در اصلاح SL دینامیک برای تیکت " + IntegerToString(ticket) + ": " + IntegerToString(trade.ResultRetcode()));  // ثبت خطا
      }
      else
      {
         Log("هیچ تغییری در SL دینامیک برای تیکت " + IntegerToString(ticket) + " لازم نیست.");  // ثبت عدم نیاز به تغییر
      }
   }
   else if (Inp_ExitLogic == EXIT_RRR)  // اگر خروج RRR
   {
      Log("خروج RRR برای Kensei - چک TP برای تیکت " + IntegerToString(ticket));  // ثبت لاگ (چک TP در جای دیگر)
   }
   Log("پایان مدیریت خروج Kensei برای تیکت: " + IntegerToString(ticket));  // ثبت پایان
}

#endif  // پایان گارد
```

```mqh
// Logging.mqh
// این فایل سیستم لاگینگ پیشرفته را پیاده‌سازی می‌کند که تمام رویدادها را به زبان فارسی ثبت می‌کند. مفید برای دیباگ و پیگیری.

#ifndef LOGGING_MQH  // جلوگیری از تعریف مجدد
#define LOGGING_MQH  // تعریف گارد

#include "Settings.mqh"  // شامل تنظیمات: مانند Inp_EnableLogging
#include "MoneyManagement.mqh"  // شامل مدیریت پول: وابستگی برای لاگ‌های مرتبط
#include "Engine_Kensei.mqh"  // شامل Kensei: برای لاگ سیگنال‌ها
#include "Engine_Hoplite.mqh"  // شامل Hoplite: مشابه

// متغیرهای جهانی لاگینگ شروع می‌شوند
string LogFileName = "ChimeraV2_Log.txt";  // نام فایل لاگ: در فولدر Files متاتریدر ذخیره می‌شود
int    g_log_handle = INVALID_HANDLE;  // هندل فایل لاگ: INVALID_HANDLE یعنی بسته است

// تابع LogInit: باز کردن فایل لاگ در شروع برنامه
void LogInit()  // بدون پارامتر، فقط چک و باز کردن فایل
{
   if (!Inp_EnableLogging) return;  // اگر لاگ غیرفعال، خروج بدون عملیات
   g_log_handle = FileOpen(LogFileName, FILE_WRITE|FILE_TXT|FILE_ANSI|FILE_SHARE_READ|FILE_SHARE_WRITE);  // باز کردن فایل با فلگ‌های نوشتن، متن، ANSI و اشتراک‌گذاری
   if (g_log_handle == INVALID_HANDLE)  // اگر باز کردن شکست
   {
      Print("خطای حیاتی: فایل لاگ باز نشد. کد خطا: " + IntegerToString(GetLastError()));  // چاپ خطا در ژورنال متاتریدر
   }
   else
   {
      Print("فایل لاگ با موفقیت باز شد.");  // چاپ موفقیت
   }
}

// تابع LogDeinit: بستن فایل لاگ در پایان برنامه
void LogDeinit()  // بدون پارامتر، چک و بستن
{
   if (g_log_handle != INVALID_HANDLE)  // اگر فایل باز است
   {
      FileClose(g_log_handle);  // بستن فایل
      g_log_handle = INVALID_HANDLE;  // تنظیم به نامعتبر برای جلوگیری از استفاده مجدد
      Print("فایل لاگ با موفقیت بسته شد.");  // چاپ موفقیت
   }
}

// تابع Log: نوشتن پیام در ژورنال و فایل - تابع اصلی لاگینگ
void Log(string message, bool is_error = false)  // پارامترها: پیام و فلگ خطا (پیش‌فرض false)
{
   if (!Inp_EnableLogging) return;  // اگر غیرفعال، خروج
   string prefix = is_error ? "خطا: " : "اطلاع: ";  // تعیین پیشوند بر اساس فلگ: برای تمایز خطا و اطلاع
   string full_message = TimeToString(TimeCurrent(), TIME_DATE|TIME_SECONDS) + " - " + prefix + message + "\r\n";  // ساخت پیام کامل با زمان و خط جدید
   Print(full_message);  // چاپ در ژورنال متاتریدر
   if (g_log_handle != INVALID_HANDLE)  // اگر فایل باز است
   {
      FileSeek(g_log_handle, 0, SEEK_END);  // رفتن به انتهای فایل برای اضافه کردن
      FileWriteString(g_log_handle, full_message);  // نوشتن پیام
      FileFlush(g_log_handle);  // فلاش برای اطمینان از ذخیره روی دیسک
   }
   else
   {
      Print("خطا در نوشتن لاگ: هندل فایل نامعتبر است.");  // چاپ خطا اگر فایل بسته باشد
   }
}

// تابع LogSignal: لاگ سیگنال‌های تولید شده - wrapper برای Log
void LogSignal(string symbol, string engine, string signal_type)  // پارامترها: نماد، موتور و نوع سیگنال
{
   string msg = "سیگنال جدید در نماد " + symbol + " از موتور " + engine + ": " + signal_type;  // ساخت پیام سیگنال
   Log(msg);  // فراخوانی Log با پیام ساخته‌شده
}

// تابع LogOpenTrade: لاگ باز شدن معاملات
void LogOpenTrade(string symbol, string direction, double lots, double sl, double tp)  // پارامترها: جزئیات معامله
{
   string msg = "باز کردن معامله در " + symbol + " - جهت: " + direction + ", حجم: " + DoubleToString(lots, 2) + ", SL: " + DoubleToString(sl, _Digits) + ", TP: " + DoubleToString(tp, _Digits);  // ساخت پیام
   Log(msg);  // فراخوانی Log
}

// تابع LogCloseTrade: لاگ بسته شدن معاملات
void LogCloseTrade(ulong ticket, string reason)  // پارامترها: تیکت و دلیل
{
   string msg = "بستن معامله با تیکت " + IntegerToString(ticket) + " به دلیل: " + reason;  // ساخت پیام
   Log(msg);  // فراخوانی Log
}

// تابع LogDrawdown: لاگ افت سرمایه فعلی
void LogDrawdown(double dd)  // پارامتر: مقدار DD
{
   string msg = "افت سرمایه فعلی پورتفولیو: " + DoubleToString(dd * 100, 2) + "%";  // ساخت پیام با تبدیل به درصد
   Log(msg);  // فراخوانی Log
}

// تابع LogError: لاگ خطاها - wrapper با فلگ خطا
void LogError(string error_msg)  // پارامتر: پیام خطا
{
   Log(error_msg, true);  // فراخوانی Log با is_error=true
}

#endif  // پایان گارد
```

```mqh
// MoneyManagement.mqh
// این فایل مدیریت پول و ریسک را پیاده‌سازی می‌کند، شامل محاسبه حجم، چک DD و باز کردن معاملات.

#ifndef MONEY_MANAGEMENT_MQH  // جلوگیری از تعریف مجدد
#define MONEY_MANAGEMENT_MQH  // تعریف گارد

#include "Settings.mqh"  // شامل تنظیمات: مانند وز‌ن‌ها و DD max
#include "Logging.mqh"  // شامل لاگینگ: برای ثبت محاسبات
#include "Engine_Kensei.mqh"  // شامل Kensei: وابستگی
#include "Engine_Hoplite.mqh"  // شامل Hoplite: وابستگی

#include <Trade\Trade.mqh>  // شامل کلاس CTrade: برای عملیات معاملاتی مانند PositionOpen

extern double g_peak_equity;  // اعلام خارجی g_peak_equity: تعریف‌شده در فایل اصلی برای دسترسی

// تابع CalculateLotSize: محاسبه حجم لات بر اساس ریسک و فاصله SL
double CalculateLotSize(string symbol, double risk_percent, double sl_pips)  // پارامترها: نماد، درصد ریسک، پیپ‌های SL - بازگشت حجم
{
   Log("محاسبه حجم لات برای " + symbol + " با ریسک " + DoubleToString(risk_percent, 2) + "% و SL " + DoubleToString(sl_pips, 1) + " پیپ");  // ثبت لاگ ورودی‌ها
   double lot_step = SymbolInfoDouble(symbol, SYMBOL_VOLUME_STEP);  // دریافت حداقل گام حجم نماد
   double tick_value = SymbolInfoDouble(symbol, SYMBOL_TRADE_TICK_VALUE);  // ارزش هر تیک (پیپ) به پول حساب
   double point = SymbolInfoDouble(symbol, SYMBOL_POINT);  // اندازه پوینت (کوچک‌ترین واحد قیمت)
   if(point == 0 || tick_value == 0)  // چک جلوگیری از تقسیم بر صفر یا مقادیر نامعتبر
   {
      LogError("اطلاعات نماد " + symbol + " برای محاسبه حجم نامعتبر است.");  // ثبت خطا
      return 0.0;  // بازگشت حجم نامعتبر
   }
   double risk_amount = AccountInfoDouble(ACCOUNT_BALANCE) * risk_percent / 100.0;  // محاسبه مبلغ ریسک بر اساس بالانس
   double sl_distance_points = sl_pips * 10;  // تبدیل پیپ به پوینت: برای جفت‌ارزهای 5 رقمی معمولاً *10
   long digits = SymbolInfoInteger(symbol, SYMBOL_DIGITS);  // دریافت تعداد ارقام اعشاری نماد
   if(digits == 3 || digits == 5) sl_distance_points = sl_pips * 10;  // تنظیم برای نمادهای 3 یا 5 رقمی (مانند JPY یا استاندارد)
   else sl_distance_points = sl_pips;  // برای دیگر نمادها مانند شاخص‌ها
   double sl_in_money = (sl_distance_points * point) * (tick_value / point);  // محاسبه ارزش مالی SL: فاصله * ارزش پوینت
   if (sl_in_money == 0)  // چک صفر بودن ارزش SL
   {
      LogError("فاصله SL محاسبه شده برای " + symbol + " صفر است. حجم قابل محاسبه نیست.");  // ثبت خطا
      return 0.0;  // بازگشت نامعتبر
   }
   double lots = risk_amount / sl_in_money;  // محاسبه حجم خام: ریسک / ارزش SL
   lots = MathFloor(lots / lot_step) * lot_step;  // گرد کردن به پایین بر اساس گام حجم: برای سازگاری با بروکر
   Log("حجم محاسبه شده: " + DoubleToString(lots, 2));  // ثبت لاگ نتیجه
   return lots;  // بازگشت حجم نهایی
}

// تابع IsPortfolioDrawdownExceeded: چک اگر DD بیش از حد مجاز باشد
bool IsPortfolioDrawdownExceeded()  // بدون پارامتر - بازگشت true اگر بیش از حد
{
   double current_dd = CalculateCurrentDrawdown();  // محاسبه DD فعلی
   LogDrawdown(current_dd);  // ثبت لاگ DD
   bool exceeded = current_dd > Inp_MaxPortfolioDrawdown;  // مقایسه با حد مجاز
   if (exceeded) Log("افت سرمایه بیش از حد مجاز تشخیص داده شد: " + DoubleToString(current_dd * 100, 2) + "%");  // ثبت هشدار اگر بیش از حد
   return exceeded;  // بازگشت نتیجه
}

// تابع CalculateCurrentDrawdown: محاسبه DD فعلی بر اساس اوج اکویتی
double CalculateCurrentDrawdown()  // بدون پارامتر - بازگشت DD به صورت اعشاری
{
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);  // دریافت اکویتی فعلی
   if (equity > g_peak_equity) g_peak_equity = equity;  // بروزرسانی اوج اگر اکویتی جدید بالاتر باشد
   double dd = (g_peak_equity > 0) ? (g_peak_equity - equity) / g_peak_equity : 0.0;  // فرمول DD: (اوج - فعلی) / اوج - چک تقسیم بر صفر
   Log("محاسبه DD فعلی: " + DoubleToString(dd * 100, 2) + "% با اوج اکویتی " + DoubleToString(g_peak_equity, 2));  // ثبت لاگ محاسبه
   return dd;  // بازگشت DD
}

// تابع OpenTrade: باز کردن معامله جدید با محاسبه حجم و تنظیم SL/TP - هندل ATR را دریافت می‌کند
void OpenTrade(string symbol, SIGNAL sig, int engine_id, int atr_handle)  // پارامترها: نماد، سیگنال، ID موتور، هندل ATR
{
   if (sig == SIGNAL_NONE) { Log("هیچ سیگنالی برای باز کردن معامله در " + symbol); return; }  // اگر بدون سیگنال، خروج
   Log("تلاش برای باز کردن معامله در " + symbol + " از موتور " + (engine_id == 1 ? "Kensei" : "Hoplite"));  // ثبت لاگ تلاش
   if (atr_handle == INVALID_HANDLE) { LogError("هندل ATR نامعتبر برای " + symbol); return; }  // چک هندل
   double sl_distance = 0.0;  // فاصله SL اولیه
   double atr_value[1];  // بافر ATR
   if (CopyBuffer(atr_handle, 0, 0, 1, atr_value) <= 0) { LogError("خطا در کپی ATR برای باز کردن معامله در " + symbol); return; }  // کپی ATR فعلی
   if (engine_id == 1)  // اگر موتور Kensei
   {
      sl_distance = atr_value[0] * Inp_Kensei_ATR_Multiplier;  // محاسبه فاصله SL بر اساس ATR و ضریب Kensei
      Log("فاصله SL محاسبه شده برای Kensei: " + DoubleToString(sl_distance, _Digits));  // ثبت لاگ
   }
   else  // اگر موتور Hoplite
   {
      sl_distance = atr_value[0] * Inp_Hoplite_StopLoss_ATR_Multiplier;  // محاسبه فاصله با ضریب Hoplite
      Log("فاصله SL محاسبه شده برای Hoplite: " + DoubleToString(sl_distance, _Digits));  // ثبت لاگ
   }
   double weight = (engine_id == 1) ? Inp_Kensei_Weight : Inp_Hoplite_Weight;  // انتخاب وزن بر اساس موتور
   double risk_percent = 1.0 * weight;  // درصد ریسک پایه 1% ضربدر وزن
   Log("درصد ریسک محاسبه شده: " + DoubleToString(risk_percent, 2) + "%");  // ثبت لاگ ریسک
   double sl_pips = sl_distance / _Point;  // تبدیل فاصله به پیپ
   double lots = CalculateLotSize(symbol, risk_percent, sl_pips);  // محاسبه حجم
   if (lots <= 0) { LogError("حجم لات نامعتبر برای " + symbol); return; }  // اگر حجم نامعتبر، خروج
   ENUM_ORDER_TYPE dir = (sig == SIGNAL_LONG) ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;  // تعیین نوع سفارش: خرید یا فروش
   double open_price = (dir == ORDER_TYPE_BUY) ? SymbolInfoDouble(symbol, SYMBOL_ASK) : SymbolInfoDouble(symbol, SYMBOL_BID);  // قیمت باز کردن: Ask برای خرید، Bid برای فروش
   double sl = (dir == ORDER_TYPE_BUY) ? open_price - sl_distance : open_price + sl_distance;  // تنظیم SL: زیر قیمت برای خرید، بالای قیمت برای فروش
   double tp = 0.0;  // TP اولیه 0 (بدون TP)
   if (Inp_ExitLogic == EXIT_RRR)  // اگر خروج RRR
   {
      tp = (dir == ORDER_TYPE_BUY) ? open_price + (sl_distance * Inp_RiskRewardRatio) : open_price - (sl_distance * Inp_RiskRewardRatio);  // محاسبه TP: فاصله SL ضربدر نسبت
      Log("TP محاسبه شده برای RRR: " + DoubleToString(tp, _Digits));  // ثبت لاگ TP
   }
   ulong magic = Inp_BaseMagicNumber + engine_id;  // مجیک نامبر: پایه + ID موتور برای تمایز
   string comment = COMMENT_PREFIX + (engine_id == 1 ? "Kensei" : "Hoplite");  // کامنت: پیشوند + نام موتور
   CTrade trade;  // ایجاد CTrade
   trade.SetExpertMagicNumber(magic);  // تنظیم مجیک نامبر در CTrade
   if (trade.PositionOpen(symbol, dir, lots, open_price, sl, tp, comment))  // باز کردن موقعیت: با قیمت بازار (open_price به جای 0 برای دقت)
      LogOpenTrade(symbol, (sig == SIGNAL_LONG ? "خرید" : "فروش"), lots, sl, tp);  // ثبت موفقیت
   else
      LogError("خطا در باز کردن معامله: " + IntegerToString(trade.ResultRetcode()));  // ثبت خطا با کد
}

#endif  // پایان گارد
```
